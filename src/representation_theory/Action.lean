/-
Copyright (c) 2020 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison
-/
import algebra.category.Group.basic
import category_theory.single_obj
import category_theory.limits.functor_category
import category_theory.limits.preserves.basic
import category_theory.adjunction.limits
import category_theory.monoidal.functor_category
import category_theory.monoidal.transport
import category_theory.monoidal.rigid.of_equivalence
import category_theory.monoidal.rigid.functor_category
import category_theory.monoidal.linear
import category_theory.monoidal.braided
import category_theory.monoidal.types
import category_theory.abelian.functor_category
import category_theory.abelian.transfer
import category_theory.conj
import category_theory.linear.functor_category

/-!
# `Action V G`, the category of actions of a monoid `G` inside some category `V`.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

The prototypical example is `V = Module R`,
where `Action (Module R) G` is the category of `R`-linear representations of `G`.

We check `Action V G ‚âå (single_obj G ‚•§ V)`,
and construct the restriction functors `res {G H : Mon} (f : G ‚ü∂ H) : Action V H ‚•§ Action V G`.

* When `V` has (co)limits so does `Action V G`.
* When `V` is monoidal, braided, or symmetric, so is `Action V G`.
* When `V` is preadditive, linear, or abelian so is `Action V G`.
-/

universes u v

open category_theory
open category_theory.limits

variables (V : Type (u+1)) [large_category V]

/--
An `Action V G` represents a bundled action of
the monoid `G` on an object of some category `V`.

As an example, when `V = Module R`, this is an `R`-linear representation of `G`,
while when `V = Type` this is a `G`-action.
-/
-- Note: this is _not_ a categorical action of `G` on `V`.
structure Action (G : Mon.{u}) :=
(V : V)
(œÅ : G ‚ü∂ Mon.of (End V))

namespace Action
variable {V}

@[simp]
lemma œÅ_one {G : Mon.{u}} (A : Action V G) : A.œÅ 1 = ùüô A.V :=
by { rw [monoid_hom.map_one], refl, }

/-- When a group acts, we can lift the action to the group of automorphisms. -/
@[simps]
def œÅ_Aut {G : Group.{u}} (A : Action V (Mon.of G)) : G ‚ü∂ Group.of (Aut A.V) :=
{ to_fun := Œª g,
  { hom := A.œÅ g,
    inv := A.œÅ (g‚Åª¬π : G),
    hom_inv_id' := ((A.œÅ).map_mul (g‚Åª¬π : G) g).symm.trans (by rw [inv_mul_self, œÅ_one]),
    inv_hom_id' := ((A.œÅ).map_mul g (g‚Åª¬π : G)).symm.trans (by rw [mul_inv_self, œÅ_one]), },
  map_one' := by { ext, exact A.œÅ.map_one },
  map_mul' := Œª x y, by { ext, exact A.œÅ.map_mul x y }, }

variable (G : Mon.{u})

section

instance inhabited' : inhabited (Action (Type u) G) := ‚ü®‚ü®punit, 1‚ü©‚ü©

/-- The trivial representation of a group. -/
def trivial : Action AddCommGroup G :=
{ V := AddCommGroup.of punit,
  œÅ := 1, }

instance : inhabited (Action AddCommGroup G) := ‚ü®trivial G‚ü©
end

variables {G V}

/--
A homomorphism of `Action V G`s is a morphism between the underlying objects,
commuting with the action of `G`.
-/
@[ext]
structure hom (M N : Action V G) :=
(hom : M.V ‚ü∂ N.V)
(comm' : ‚àÄ g : G, M.œÅ g ‚â´ hom = hom ‚â´ N.œÅ g . obviously)

restate_axiom hom.comm'

namespace hom

/-- The identity morphism on a `Action V G`. -/
@[simps]
def id (M : Action V G) : Action.hom M M :=
{ hom := ùüô M.V }

instance (M : Action V G) : inhabited (Action.hom M M) := ‚ü®id M‚ü©

/--
The composition of two `Action V G` homomorphisms is the composition of the underlying maps.
-/
@[simps]
def comp {M N K : Action V G} (p : Action.hom M N) (q : Action.hom N K) :
  Action.hom M K :=
{ hom := p.hom ‚â´ q.hom,
  comm' := Œª g, by rw [‚Üêcategory.assoc, p.comm, category.assoc, q.comm, ‚Üêcategory.assoc] }

end hom

instance : category (Action V G) :=
{ hom := Œª M N, hom M N,
  id := Œª M, hom.id M,
  comp := Œª M N K f g, hom.comp f g, }

@[simp]
lemma id_hom (M : Action V G) : (ùüô M : hom M M).hom = ùüô M.V := rfl
@[simp]
lemma comp_hom {M N K : Action V G} (f : M ‚ü∂ N) (g : N ‚ü∂ K) :
  (f ‚â´ g : hom M K).hom = f.hom ‚â´ g.hom :=
rfl

/-- Construct an isomorphism of `G` actions/representations
from an isomorphism of the the underlying objects,
where the forward direction commutes with the group action. -/
@[simps]
def mk_iso {M N : Action V G} (f : M.V ‚âÖ N.V) (comm : ‚àÄ g : G, M.œÅ g ‚â´ f.hom = f.hom ‚â´ N.œÅ g) :
  M ‚âÖ N :=
{ hom :=
  { hom := f.hom,
    comm' := comm, },
  inv :=
  { hom := f.inv,
    comm' := Œª g, by { have w := comm g =‚â´ f.inv, simp at w, simp [w], }, }}

@[priority 100]
instance is_iso_of_hom_is_iso {M N : Action V G} (f : M ‚ü∂ N) [is_iso f.hom] : is_iso f :=
by { convert is_iso.of_iso (mk_iso (as_iso f.hom) f.comm), ext, refl, }

instance is_iso_hom_mk {M N : Action V G} (f : M.V ‚ü∂ N.V) [is_iso f] (w) :
  @is_iso _ _ M N ‚ü®f, w‚ü© :=
is_iso.of_iso (mk_iso (as_iso f) w)

namespace functor_category_equivalence

/-- Auxilliary definition for `functor_category_equivalence`. -/
@[simps]
def functor : Action V G ‚•§ (single_obj G ‚•§ V) :=
{ obj := Œª M,
  { obj := Œª _, M.V,
    map := Œª _ _ g, M.œÅ g,
    map_id' := Œª _, M.œÅ.map_one,
    map_comp' := Œª _ _ _ g h, M.œÅ.map_mul h g, },
  map := Œª M N f,
  { app := Œª _, f.hom,
    naturality' := Œª _ _ g, f.comm g, } }

/-- Auxilliary definition for `functor_category_equivalence`. -/
@[simps]
def inverse : (single_obj G ‚•§ V) ‚•§ Action V G :=
{ obj := Œª F,
  { V := F.obj punit.star,
    œÅ :=
    { to_fun := Œª g, F.map g,
      map_one' := F.map_id punit.star,
      map_mul' := Œª g h, F.map_comp h g, } },
  map := Œª M N f,
  { hom := f.app punit.star,
    comm' := Œª g, f.naturality g, } }.

/-- Auxilliary definition for `functor_category_equivalence`. -/
@[simps]
def unit_iso : ùü≠ (Action V G) ‚âÖ functor ‚ãô inverse :=
nat_iso.of_components (Œª M, mk_iso ((iso.refl _)) (by tidy)) (by tidy).

/-- Auxilliary definition for `functor_category_equivalence`. -/
@[simps]
def counit_iso : inverse ‚ãô functor ‚âÖ ùü≠ (single_obj G ‚•§ V) :=
nat_iso.of_components (Œª M, nat_iso.of_components (by tidy) (by tidy)) (by tidy).

end functor_category_equivalence

section
open functor_category_equivalence

variables (V G)

/--
The category of actions of `G` in the category `V`
is equivalent to the functor category `single_obj G ‚•§ V`.
-/
def functor_category_equivalence : Action V G ‚âå (single_obj G ‚•§ V) :=
{ functor := functor,
  inverse := inverse,
  unit_iso := unit_iso,
  counit_iso := counit_iso, }

attribute [simps] functor_category_equivalence

lemma functor_category_equivalence.functor_def :
  (functor_category_equivalence V G).functor = functor_category_equivalence.functor := rfl

lemma functor_category_equivalence.inverse_def :
  (functor_category_equivalence V G).inverse = functor_category_equivalence.inverse := rfl

instance [has_finite_products V] : has_finite_products (Action V G) :=
{ out := Œª n, adjunction.has_limits_of_shape_of_equivalence
    (Action.functor_category_equivalence _ _).functor }

instance [has_finite_limits V] : has_finite_limits (Action V G) :=
{ out := Œª J _ _, by exactI adjunction.has_limits_of_shape_of_equivalence
    (Action.functor_category_equivalence _ _).functor }

instance [has_limits V] : has_limits (Action V G) :=
adjunction.has_limits_of_equivalence (Action.functor_category_equivalence _ _).functor

instance [has_colimits V] : has_colimits (Action V G) :=
adjunction.has_colimits_of_equivalence (Action.functor_category_equivalence _ _).functor

end

section forget

variables (V G)

/-- (implementation) The forgetful functor from bundled actions to the underlying objects.

Use the `category_theory.forget` API provided by the `concrete_category` instance below,
rather than using this directly.
-/
@[simps]
def forget : Action V G ‚•§ V :=
{ obj := Œª M, M.V,
  map := Œª M N f, f.hom, }

instance : faithful (forget V G) :=
{ map_injective' := Œª X Y f g w, hom.ext _ _ w, }

instance [concrete_category V] : concrete_category (Action V G) :=
{ forget := forget V G ‚ãô (concrete_category.forget V), }

instance has_forget_to_V [concrete_category V] : has_forget‚ÇÇ (Action V G) V :=
{ forget‚ÇÇ := forget V G }

/-- The forgetful functor is intertwined by `functor_category_equivalence` with
evaluation at `punit.star`. -/
def functor_category_equivalence_comp_evaluation :
  (functor_category_equivalence V G).functor ‚ãô (evaluation _ _).obj punit.star ‚âÖ forget V G :=
iso.refl _

noncomputable instance [has_limits V] : limits.preserves_limits (forget V G) :=
limits.preserves_limits_of_nat_iso
  (Action.functor_category_equivalence_comp_evaluation V G)

noncomputable instance [has_colimits V] : preserves_colimits (forget V G) :=
preserves_colimits_of_nat_iso
  (Action.functor_category_equivalence_comp_evaluation V G)

-- TODO construct categorical images?

end forget

lemma iso.conj_œÅ {M N : Action V G} (f : M ‚âÖ N) (g : G) :
   N.œÅ g = (((forget V G).map_iso f).conj (M.œÅ g)) :=
by { rw [iso.conj_apply, iso.eq_inv_comp], simp [f.hom.comm'] }

section has_zero_morphisms
variables [has_zero_morphisms V]

instance : has_zero_morphisms (Action V G) :=
{ has_zero := Œª X Y, ‚ü®‚ü®0, by { intro g, simp }‚ü©‚ü©,
  comp_zero' := Œª P Q f R, by { ext1, simp },
  zero_comp' := Œª P Q R f, by { ext1, simp }, }

instance forget_preserves_zero_morphisms : functor.preserves_zero_morphisms (forget V G) := {}
instance forget‚ÇÇ_preserves_zero_morphisms [concrete_category V] :
  functor.preserves_zero_morphisms (forget‚ÇÇ (Action V G) V) := {}
instance functor_category_equivalence_preserves_zero_morphisms :
  functor.preserves_zero_morphisms (functor_category_equivalence V G).functor := {}

end has_zero_morphisms

section preadditive
variables [preadditive V]

instance : preadditive (Action V G) :=
{ hom_group := Œª X Y,
  { zero := ‚ü®0, by simp‚ü©,
    add := Œª f g, ‚ü®f.hom + g.hom, by simp [f.comm, g.comm]‚ü©,
    neg := Œª f, ‚ü®-f.hom, by simp [f.comm]‚ü©,
    zero_add := by { intros, ext, exact zero_add _, },
    add_zero := by { intros, ext, exact add_zero _, },
    add_assoc := by { intros, ext, exact add_assoc _ _ _, },
    add_left_neg := by { intros, ext, exact add_left_neg _, },
    add_comm := by { intros, ext, exact add_comm _ _, }, },
  add_comp' := by { intros, ext, exact preadditive.add_comp _ _ _ _ _ _, },
  comp_add' := by { intros, ext, exact preadditive.comp_add _ _ _ _ _ _, }, }

instance forget_additive :
  functor.additive (forget V G) := {}
instance forget‚ÇÇ_additive [concrete_category V] :
  functor.additive (forget‚ÇÇ (Action V G) V) := {}
instance functor_category_equivalence_additive :
  functor.additive (functor_category_equivalence V G).functor := {}

@[simp] lemma zero_hom {X Y : Action V G} : (0 : X ‚ü∂ Y).hom = 0 := rfl
@[simp] lemma neg_hom {X Y : Action V G} (f : X ‚ü∂ Y) : (-f).hom = -f.hom := rfl
@[simp] lemma add_hom {X Y : Action V G} (f g : X ‚ü∂ Y) : (f + g).hom = f.hom + g.hom := rfl
@[simp] lemma sum_hom {X Y : Action V G} {Œπ : Type*} (f : Œπ ‚Üí (X ‚ü∂ Y)) (s : finset Œπ) :
  (s.sum f).hom = s.sum (Œª i, (f i).hom) := (forget V G).map_sum f s

end preadditive

section linear
variables [preadditive V] {R : Type*} [semiring R] [linear R V]

instance : linear R (Action V G) :=
{ hom_module := Œª X Y,
  { smul := Œª r f, ‚ü®r ‚Ä¢ f.hom, by simp [f.comm]‚ü©,
    one_smul := by { intros, ext, exact one_smul _ _, },
    smul_zero := by { intros, ext, exact smul_zero _, },
    zero_smul := by { intros, ext, exact zero_smul _ _, },
    add_smul := by { intros, ext, exact add_smul _ _ _, },
    smul_add := by { intros, ext, exact smul_add _ _ _, },
    mul_smul := by { intros, ext, exact mul_smul _ _ _, }, },
  smul_comp' := by { intros, ext, exact linear.smul_comp _ _ _ _ _ _, },
  comp_smul' := by { intros, ext, exact linear.comp_smul _ _ _ _ _ _, }, }

instance forget_linear :
  functor.linear R (forget V G) := {}
instance forget‚ÇÇ_linear [concrete_category V] :
  functor.linear R (forget‚ÇÇ (Action V G) V) := {}
instance functor_category_equivalence_linear :
  functor.linear R (functor_category_equivalence V G).functor := {}

@[simp] lemma smul_hom {X Y : Action V G} (r : R) (f : X ‚ü∂ Y) : (r ‚Ä¢ f).hom = r ‚Ä¢ f.hom := rfl

end linear

section abelian
/-- Auxilliary construction for the `abelian (Action V G)` instance. -/
def abelian_aux : Action V G ‚âå (ulift.{u} (single_obj G) ‚•§ V) :=
(functor_category_equivalence V G).trans (equivalence.congr_left ulift.equivalence)

noncomputable instance [abelian V] : abelian (Action V G) :=
abelian_of_equivalence abelian_aux.functor

end abelian

section monoidal
variables [monoidal_category V]

instance : monoidal_category (Action V G) :=
monoidal.transport (Action.functor_category_equivalence _ _).symm

@[simp] lemma tensor_unit_V : (ùüô_ (Action V G)).V = ùüô_ V := rfl
@[simp] lemma tensor_unit_rho {g : G} : (ùüô_ (Action V G)).œÅ g = ùüô (ùüô_ V) := rfl
@[simp] lemma tensor_V {X Y : Action V G} : (X ‚äó Y).V = X.V ‚äó Y.V := rfl
@[simp] lemma tensor_rho {X Y : Action V G} {g : G} : (X ‚äó Y).œÅ g = X.œÅ g ‚äó Y.œÅ g := rfl
@[simp] lemma tensor_hom {W X Y Z : Action V G} (f : W ‚ü∂ X) (g : Y ‚ü∂ Z) :
  (f ‚äó g).hom = f.hom ‚äó g.hom := rfl
@[simp] lemma associator_hom_hom {X Y Z : Action V G} :
  hom.hom (Œ±_ X Y Z).hom = (Œ±_ X.V Y.V Z.V).hom :=
begin
  dsimp [monoidal.transport_associator],
  simp,
end
@[simp] lemma associator_inv_hom {X Y Z : Action V G} :
  hom.hom (Œ±_ X Y Z).inv = (Œ±_ X.V Y.V Z.V).inv :=
begin
  dsimp [monoidal.transport_associator],
  simp,
end
@[simp] lemma left_unitor_hom_hom {X : Action V G} :
  hom.hom (Œª_ X).hom = (Œª_ X.V).hom :=
begin
  dsimp [monoidal.transport_left_unitor],
  simp,
end
@[simp] lemma left_unitor_inv_hom {X : Action V G} :
  hom.hom (Œª_ X).inv = (Œª_ X.V).inv :=
begin
  dsimp [monoidal.transport_left_unitor],
  simp,
end
@[simp] lemma right_unitor_hom_hom {X : Action V G} :
  hom.hom (œÅ_ X).hom = (œÅ_ X.V).hom :=
begin
  dsimp [monoidal.transport_right_unitor],
  simp,
end
@[simp] lemma right_unitor_inv_hom {X : Action V G} :
  hom.hom (œÅ_ X).inv = (œÅ_ X.V).inv :=
begin
  dsimp [monoidal.transport_right_unitor],
  simp,
end

/-- Given an object `X` isomorphic to the tensor unit of `V`, `X` equipped with the trivial action
is isomorphic to the tensor unit of `Action V G`. -/
def tensor_unit_iso {X : V} (f : ùüô_ V ‚âÖ X) :
  ùüô_ (Action V G) ‚âÖ Action.mk X 1 :=
Action.mk_iso f (Œª g, by simp only [monoid_hom.one_apply, End.one_def, category.id_comp f.hom,
  tensor_unit_rho, category.comp_id])

variables (V G)

/-- When `V` is monoidal the forgetful functor `Action V G` to `V` is monoidal. -/
@[simps]
def forget_monoidal : monoidal_functor (Action V G) V :=
{ Œµ := ùüô _,
  Œº := Œª X Y, ùüô _,
  ..Action.forget _ _, }

instance forget_monoidal_faithful : faithful (forget_monoidal V G).to_functor :=
by { change faithful (forget V G), apply_instance, }

section
variables [braided_category V]

instance : braided_category (Action V G) :=
braided_category_of_faithful (forget_monoidal V G) (Œª X Y, mk_iso (Œ≤_ _ _) (by tidy)) (by tidy)

/-- When `V` is braided the forgetful functor `Action V G` to `V` is braided. -/
@[simps]
def forget_braided : braided_functor (Action V G) V :=
{ ..forget_monoidal _ _, }

instance forget_braided_faithful : faithful (forget_braided V G).to_functor :=
by { change faithful (forget V G), apply_instance, }

end

instance [symmetric_category V] : symmetric_category (Action V G) :=
symmetric_category_of_faithful (forget_braided V G)

section
variables [preadditive V] [monoidal_preadditive V]

local attribute [simp] monoidal_preadditive.tensor_add monoidal_preadditive.add_tensor

instance : monoidal_preadditive (Action V G) := {}

variables {R : Type*} [semiring R] [linear R V] [monoidal_linear R V]

instance : monoidal_linear R (Action V G) := {}

end

variables (V G)
noncomputable theory

/-- Upgrading the functor `Action V G ‚•§ (single_obj G ‚•§ V)` to a monoidal functor. -/
def functor_category_monoidal_equivalence : monoidal_functor (Action V G) (single_obj G ‚•§ V) :=
monoidal.from_transported (Action.functor_category_equivalence _ _).symm

instance : is_equivalence ((functor_category_monoidal_equivalence V G).to_functor) :=
by { change is_equivalence (Action.functor_category_equivalence _ _).functor, apply_instance, }

@[simp] lemma functor_category_monoidal_equivalence.Œº_app (A B : Action V G) :
  ((functor_category_monoidal_equivalence V G).Œº A B).app punit.star = ùüô _ :=
begin
  dunfold functor_category_monoidal_equivalence,
  simp only [monoidal.from_transported_to_lax_monoidal_functor_Œº],
  show (ùüô A.V ‚äó ùüô B.V) ‚â´ ùüô (A.V ‚äó B.V) ‚â´ (ùüô A.V ‚äó ùüô B.V) = ùüô (A.V ‚äó B.V),
  simp only [monoidal_category.tensor_id, category.comp_id],
end

@[simp] lemma functor_category_monoidal_equivalence.Œº_iso_inv_app (A B : Action V G) :
  ((functor_category_monoidal_equivalence V G).Œº_iso A B).inv.app punit.star = ùüô _ :=
begin
  rw [‚Üênat_iso.app_inv, ‚Üêis_iso.iso.inv_hom],
  refine is_iso.inv_eq_of_hom_inv_id _,
  rw [category.comp_id, nat_iso.app_hom, monoidal_functor.Œº_iso_hom,
    functor_category_monoidal_equivalence.Œº_app],
end

@[simp] lemma functor_category_monoidal_equivalence.Œµ_app :
  (functor_category_monoidal_equivalence V G).Œµ.app punit.star = ùüô _ :=
begin
  dunfold functor_category_monoidal_equivalence,
  simp only [monoidal.from_transported_to_lax_monoidal_functor_Œµ],
  show ùüô (monoidal_category.tensor_unit V) ‚â´ _ = ùüô (monoidal_category.tensor_unit V),
  rw [nat_iso.is_iso_inv_app, category.id_comp],
  exact is_iso.inv_id,
end

@[simp] lemma functor_category_monoidal_equivalence.inv_counit_app_hom (A : Action V G) :
  ((functor_category_monoidal_equivalence _ _).inv.adjunction.counit.app A).hom = ùüô _ :=
rfl

@[simp] lemma functor_category_monoidal_equivalence.counit_app (A : single_obj G ‚•§ V) :
  ((functor_category_monoidal_equivalence _ _).adjunction.counit.app A).app punit.star = ùüô _ := rfl

@[simp] lemma functor_category_monoidal_equivalence.inv_unit_app_app
  (A : single_obj G ‚•§ V) :
  ((functor_category_monoidal_equivalence _ _).inv.adjunction.unit.app A).app
  punit.star = ùüô _ := rfl

@[simp] lemma functor_category_monoidal_equivalence.unit_app_hom (A : Action V G) :
  ((functor_category_monoidal_equivalence _ _).adjunction.unit.app A).hom = ùüô _ :=
rfl

@[simp] lemma functor_category_monoidal_equivalence.functor_map {A B : Action V G} (f : A ‚ü∂ B) :
  (functor_category_monoidal_equivalence _ _).map f
    = functor_category_equivalence.functor.map f := rfl

@[simp] lemma functor_category_monoidal_equivalence.inverse_map
  {A B : single_obj G ‚•§ V} (f : A ‚ü∂ B) :
  (functor_category_monoidal_equivalence _ _).inv.map f
    = functor_category_equivalence.inverse.map f := rfl

variables (H : Group.{u})

instance [right_rigid_category V] : right_rigid_category (single_obj (H : Mon.{u}) ‚•§ V) :=
by { change right_rigid_category (single_obj H ‚•§ V), apply_instance }

/-- If `V` is right rigid, so is `Action V G`. -/
instance [right_rigid_category V] : right_rigid_category (Action V H) :=
right_rigid_category_of_equivalence (functor_category_monoidal_equivalence V _)

instance [left_rigid_category V] : left_rigid_category (single_obj (H : Mon.{u}) ‚•§ V) :=
by { change left_rigid_category (single_obj H ‚•§ V), apply_instance }

/-- If `V` is left rigid, so is `Action V G`. -/
instance [left_rigid_category V] : left_rigid_category (Action V H) :=
left_rigid_category_of_equivalence (functor_category_monoidal_equivalence V _)

instance [rigid_category V] : rigid_category (single_obj (H : Mon.{u}) ‚•§ V) :=
by { change rigid_category (single_obj H ‚•§ V), apply_instance }

/-- If `V` is rigid, so is `Action V G`. -/
instance [rigid_category V] : rigid_category (Action V H) :=
rigid_category_of_equivalence (functor_category_monoidal_equivalence V _)

variables {V H} (X : Action V H)

@[simp] lemma right_dual_V [right_rigid_category V] : (X·òÅ).V = (X.V)·òÅ := rfl

@[simp] lemma left_dual_V [left_rigid_category V] : (·òÅX).V = ·òÅ(X.V) := rfl

@[simp] lemma right_dual_œÅ [right_rigid_category V] (h : H) : (X·òÅ).œÅ h = (X.œÅ (h‚Åª¬π : H))·òÅ :=
by { rw ‚Üêsingle_obj.inv_as_inv, refl }

@[simp] lemma left_dual_œÅ [left_rigid_category V] (h : H) : (·òÅX).œÅ h = ·òÅ(X.œÅ (h‚Åª¬π : H)) :=
by { rw ‚Üêsingle_obj.inv_as_inv, refl }

end monoidal

/-- Actions/representations of the trivial group are just objects in the ambient category. -/
def Action_punit_equivalence : Action V (Mon.of punit) ‚âå V :=
{ functor := forget V _,
  inverse :=
  { obj := Œª X, ‚ü®X, 1‚ü©,
    map := Œª X Y f, ‚ü®f, Œª ‚ü®‚ü©, by simp‚ü©, },
  unit_iso := nat_iso.of_components (Œª X, mk_iso (iso.refl _) (Œª ‚ü®‚ü©, by simpa using œÅ_one X))
    (by tidy),
  counit_iso := nat_iso.of_components (Œª X, iso.refl _) (by tidy), }

variables (V)
/--
The "restriction" functor along a monoid homomorphism `f : G ‚ü∂ H`,
taking actions of `H` to actions of `G`.

(This makes sense for any homomorphism, but the name is natural when `f` is a monomorphism.)
-/
@[simps]
def res {G H : Mon} (f : G ‚ü∂ H) : Action V H ‚•§ Action V G :=
{ obj := Œª M,
  { V := M.V,
    œÅ := f ‚â´ M.œÅ },
  map := Œª M N p,
  { hom := p.hom,
    comm' := Œª g, p.comm (f g) } }

/--
The natural isomorphism from restriction along the identity homomorphism to
the identity functor on `Action V G`.
-/
def res_id {G : Mon} : res V (ùüô G) ‚âÖ ùü≠ (Action V G) :=
nat_iso.of_components (Œª M, mk_iso (iso.refl _) (by tidy)) (by tidy)

attribute [simps] res_id

/--
The natural isomorphism from the composition of restrictions along homomorphisms
to the restriction along the composition of homomorphism.
-/
def res_comp {G H K : Mon} (f : G ‚ü∂ H) (g : H ‚ü∂ K) : res V g ‚ãô res V f ‚âÖ res V (f ‚â´ g) :=
nat_iso.of_components (Œª M, mk_iso (iso.refl _) (by tidy)) (by tidy)

attribute [simps] res_comp

-- TODO promote `res` to a pseudofunctor from
-- the locally discrete bicategory constructed from `Mon·µí·µñ` to `Cat`, sending `G` to `Action V G`.

variables {G} {H : Mon.{u}} (f : G ‚ü∂ H)

instance res_additive [preadditive V] : (res V f).additive := {}

variables {R : Type*} [semiring R]

instance res_linear [preadditive V] [linear R V] : (res V f).linear R := {}

/-- Bundles a type `H` with a multiplicative action of `G` as an `Action`. -/
def of_mul_action (G H : Type u) [monoid G] [mul_action G H] : Action (Type u) (Mon.of G) :=
{ V := H,
  œÅ := @mul_action.to_End_hom _ _ _ (by assumption) }

@[simp] lemma of_mul_action_apply {G H : Type u} [monoid G] [mul_action G H] (g : G) (x : H) :
  (of_mul_action G H).œÅ g x = (g ‚Ä¢ x : H) :=
rfl

/-- Given a family `F` of types with `G`-actions, this is the limit cone demonstrating that the
product of `F` as types is a product in the category of `G`-sets. -/
def of_mul_action_limit_cone {Œπ : Type v} (G : Type (max v u)) [monoid G]
  (F : Œπ ‚Üí Type (max v u)) [Œ† i : Œπ, mul_action G (F i)] :
  limit_cone (discrete.functor (Œª i : Œπ, Action.of_mul_action G (F i))) :=
{ cone :=
  { X := Action.of_mul_action G (Œ† i : Œπ, F i),
    œÄ :=
    { app := Œª i, ‚ü®Œª x, x i.as, Œª g, by ext; refl‚ü©,
      naturality' := Œª i j x,
      begin
        ext,
        discrete_cases,
        cases x,
        congr
      end } },
  is_limit :=
  { lift := Œª s,
    { hom := Œª x i, (s.œÄ.app ‚ü®i‚ü©).hom x,
      comm' := Œª g,
      begin
        ext x j,
        dsimp,
        exact congr_fun ((s.œÄ.app ‚ü®j‚ü©).comm g) x,
      end },
    fac' := Œª s j,
    begin
      ext,
      dsimp,
      congr,
      rw discrete.mk_as,
    end,
    uniq' := Œª s f h,
    begin
      ext x j,
      dsimp at *,
      rw ‚Üêh ‚ü®j‚ü©,
      congr,
    end } }

/-- The `G`-set `G`, acting on itself by left multiplication. -/
@[simps] def left_regular (G : Type u) [monoid G] : Action (Type u) (Mon.of G) :=
Action.of_mul_action G G

/-- The `G`-set `G‚Åø`, acting on itself by left multiplication. -/
@[simps] def diagonal (G : Type u) [monoid G] (n : ‚Ñï) : Action (Type u) (Mon.of G) :=
Action.of_mul_action G (fin n ‚Üí G)

/-- We have `fin 1 ‚Üí G ‚âÖ G` as `G`-sets, with `G` acting by left multiplication. -/
def diagonal_one_iso_left_regular (G : Type u) [monoid G] :
  diagonal G 1 ‚âÖ left_regular G := Action.mk_iso (equiv.fun_unique _ _).to_iso (Œª g, rfl)

/-- Given `X : Action (Type u) (Mon.of G)` for `G` a group, then `G √ó X` (with `G` acting as left
multiplication on the first factor and by `X.œÅ` on the second) is isomorphic as a `G`-set to
`G √ó X` (with `G` acting as left multiplication on the first factor and trivially on the second).
The isomorphism is given by `(g, x) ‚Ü¶ (g, g‚Åª¬π ‚Ä¢ x)`. -/
@[simps] def left_regular_tensor_iso (G : Type u) [group G]
  (X : Action (Type u) (Mon.of G)) :
  left_regular G ‚äó X ‚âÖ left_regular G ‚äó Action.mk X.V 1 :=
{ hom :=
  { hom := Œª g, ‚ü®g.1, (X.œÅ (g.1‚Åª¬π : G) g.2 : X.V)‚ü©,
    comm' := Œª g, funext $ Œª x, prod.ext rfl $
      show (X.œÅ ((g * x.1)‚Åª¬π : G) * X.œÅ g) x.2 = _,
      by simpa only [mul_inv_rev, ‚ÜêX.œÅ.map_mul, inv_mul_cancel_right] },
  inv :=
  { hom := Œª g, ‚ü®g.1, X.œÅ g.1 g.2‚ü©,
    comm' := Œª g, funext $ Œª x, prod.ext rfl $
      by simpa only [tensor_rho, types_comp_apply, tensor_apply, left_regular_œÅ_apply, map_mul] },
  hom_inv_id' := hom.ext _ _ (funext $ Œª x, prod.ext rfl $
    show (X.œÅ x.1 * X.œÅ (x.1‚Åª¬π : G)) x.2 = _,
      by simpa only [‚ÜêX.œÅ.map_mul, mul_inv_self, X.œÅ.map_one]),
  inv_hom_id' := hom.ext _ _ (funext $ Œª x, prod.ext rfl $
    show (X.œÅ (x.1‚Åª¬π : G) * X.œÅ x.1) _ = _,
      by simpa only [‚ÜêX.œÅ.map_mul, inv_mul_self, X.œÅ.map_one]) }

/-- The natural isomorphism of `G`-sets `G‚Åø‚Å∫¬π ‚âÖ G √ó G‚Åø`, where `G` acts by left multiplication on
each factor. -/
@[simps] def diagonal_succ (G : Type u) [monoid G] (n : ‚Ñï) :
  diagonal G (n + 1) ‚âÖ left_regular G ‚äó diagonal G n :=
mk_iso (equiv.pi_fin_succ_above_equiv _ 0).to_iso (Œª g, rfl)

end Action

namespace category_theory.functor

variables {V} {W : Type (u+1)} [large_category W]

/-- A functor between categories induces a functor between
the categories of `G`-actions within those categories. -/
@[simps]
def map_Action (F : V ‚•§ W) (G : Mon.{u}) : Action V G ‚•§ Action W G :=
{ obj := Œª M,
  { V := F.obj M.V,
    œÅ :=
    { to_fun := Œª g, F.map (M.œÅ g),
      map_one' := by simp only [End.one_def, Action.œÅ_one, F.map_id],
      map_mul' := Œª g h, by simp only [End.mul_def, F.map_comp, map_mul], }, },
  map := Œª M N f,
  { hom := F.map f.hom,
    comm' := Œª g, by { dsimp, rw [‚ÜêF.map_comp, f.comm, F.map_comp], }, },
  map_id' := Œª M, by { ext, simp only [Action.id_hom, F.map_id], },
  map_comp' := Œª M N P f g, by { ext, simp only [Action.comp_hom, F.map_comp], }, }

variables (F : V ‚•§ W) (G : Mon.{u}) [preadditive V] [preadditive W]

instance map_Action_preadditive [F.additive] : (F.map_Action G).additive := {}

variables {R : Type*} [semiring R] [category_theory.linear R V] [category_theory.linear R W]

instance map_Action_linear [F.additive] [F.linear R] : (F.map_Action G).linear R := {}

end category_theory.functor

namespace category_theory.monoidal_functor

open Action
variables {V} {W : Type (u+1)} [large_category W] [monoidal_category V] [monoidal_category W]
  (F : monoidal_functor V W) (G : Mon.{u})

/-- A monoidal functor induces a monoidal functor between
the categories of `G`-actions within those categories. -/
@[simps] def map_Action :
  monoidal_functor (Action V G) (Action W G) :=
{ Œµ :=
  { hom := F.Œµ,
    comm' := Œª g,
    by { dsimp, erw [category.id_comp, category_theory.functor.map_id, category.comp_id], }, },
  Œº := Œª X Y,
  { hom := F.Œº X.V Y.V,
    comm' := Œª g, F.to_lax_monoidal_functor.Œº_natural (X.œÅ g) (Y.œÅ g), },
  Œµ_is_iso := by apply_instance,
  Œº_is_iso := by apply_instance,
  Œº_natural' := by { intros, ext, dsimp, simp, },
  associativity' := by { intros, ext, dsimp, simp, dsimp, simp, }, -- See note [dsimp, simp].
  left_unitality' := by { intros, ext, dsimp, simp, dsimp, simp, },
  right_unitality' := by { intros, ext, dsimp, simp, dsimp, simp, },
  ..F.to_functor.map_Action G, }

@[simp] lemma map_Action_Œµ_inv_hom :
  (inv (F.map_Action G).Œµ).hom = inv F.Œµ :=
begin
  ext,
  simp only [‚ÜêF.map_Action_to_lax_monoidal_functor_Œµ_hom G, ‚ÜêAction.comp_hom,
    is_iso.hom_inv_id, id_hom],
end

@[simp] lemma map_Action_Œº_inv_hom (X Y : Action V G) :
  (inv ((F.map_Action G).Œº X Y)).hom = inv (F.Œº X.V Y.V) :=
begin
  ext,
  simpa only [‚ÜêF.map_Action_to_lax_monoidal_functor_Œº_hom G, ‚ÜêAction.comp_hom,
    is_iso.hom_inv_id, id_hom],
end

end category_theory.monoidal_functor
