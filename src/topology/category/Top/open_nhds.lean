/-
Copyright (c) 2019 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison
-/
import topology.category.Top.opens
import category_theory.filtered

open category_theory
open topological_space
open opposite

universe u

variables {X Y : Top.{u}} (f : X ‚ü∂ Y)

namespace topological_space

def open_nhds (x : X) := { U : opens X // x ‚àà U }

namespace open_nhds

instance (x : X) : partial_order (open_nhds x) :=
{ le := Œª U V, U.1 ‚â§ V.1,
  le_refl := Œª _, le_refl _,
  le_trans := Œª _ _ _, le_trans,
  le_antisymm := Œª _ _ i j, subtype.eq $ le_antisymm i j }

instance (x : X) : lattice (open_nhds x) :=
{ inf := Œª U V, ‚ü®U.1 ‚äì V.1, ‚ü®U.2, V.2‚ü©‚ü©,
  le_inf := Œª U V W, @le_inf _ _ U.1.1 V.1.1 W.1.1,
  inf_le_left := Œª U V, @inf_le_left _ _ U.1.1 V.1.1,
  inf_le_right := Œª U V, @inf_le_right _ _ U.1.1 V.1.1,
  sup := Œª U V, ‚ü®U.1 ‚äî V.1, V.1.1.mem_union_left U.2‚ü©,
  sup_le := Œª U V W, @sup_le _ _ U.1.1 V.1.1 W.1.1,
  le_sup_left := Œª U V, @le_sup_left _ _ U.1.1 V.1.1,
  le_sup_right := Œª U V, @le_sup_right _ _ U.1.1 V.1.1,
  ..open_nhds.partial_order x }

instance (x : X) : order_top (open_nhds x) :=
{ top := ‚ü®‚ä§, trivial‚ü©,
  le_top := Œª U, @le_top _ _ U.1.1,
  ..open_nhds.partial_order x }

instance open_nhds_category (x : X) : category.{u} (open_nhds x) :=
by {unfold open_nhds, apply_instance}

instance opens_nhds_hom_has_coe_to_fun {x : X} {U V : open_nhds x} : has_coe_to_fun (U ‚ü∂ V) :=
{ F := Œª f, U.1 ‚Üí V.1,
  coe := Œª f x, ‚ü®x, (le_of_hom f) x.2‚ü© }

/--
The inclusion `U ‚äì V ‚ü∂ U` as a morphism in the category of open sets.
-/
def inf_le_left {x : X} (U V : open_nhds x) : U ‚äì V ‚ü∂ U :=
hom_of_le inf_le_left

/--
The inclusion `U ‚äì V ‚ü∂ V` as a morphism in the category of open sets.
-/
def inf_le_right {x : X} (U V : open_nhds x) : U ‚äì V ‚ü∂ V :=
hom_of_le inf_le_right

def inclusion (x : X) : open_nhds x ‚•§ opens X :=
full_subcategory_inclusion _

@[simp] lemma inclusion_obj (x : X) (U) (p) : (inclusion x).obj ‚ü®U,p‚ü© = U := rfl

lemma open_embedding {x : X} (U : open_nhds x) : open_embedding (U.1.inclusion) :=
U.1.open_embedding

instance open_nhds_is_filtered (x : X) : is_filtered (open_nhds x)·µí·µñ :=
{ nonempty := ‚ü®op ‚ä§‚ü©,
  cocone_objs := Œª U V, ‚ü®op (unop U ‚äì unop V),
    (inf_le_left (unop U) (unop V)).op, (inf_le_right (unop U) (unop V)).op, trivial‚ü© ,
  cocone_maps := Œª U V i j, ‚ü®V, ùüô V, rfl‚ü©, }

def map (x : X) : open_nhds (f x) ‚•§ open_nhds x :=
{ obj := Œª U, ‚ü®(opens.map f).obj U.1, by tidy‚ü©,
  map := Œª U V i, (opens.map f).map i }

@[simp] lemma map_obj (x : X) (U) (q) : (map f x).obj ‚ü®U, q‚ü© = ‚ü®(opens.map f).obj U, by tidy‚ü© :=
rfl
@[simp] lemma map_id_obj (x : X) (U) : (map (ùüô X) x).obj U = U :=
by tidy
@[simp] lemma map_id_obj' (x : X) (U) (p) (q) : (map (ùüô X) x).obj ‚ü®‚ü®U, p‚ü©, q‚ü© = ‚ü®‚ü®U, p‚ü©, q‚ü© :=
rfl

@[simp] lemma map_id_obj_unop (x : X) (U : (open_nhds x)·µí·µñ) : (map (ùüô X) x).obj (unop U) = unop U :=
by simp
@[simp] lemma op_map_id_obj (x : X) (U : (open_nhds x)·µí·µñ) : (map (ùüô X) x).op.obj U = U :=
by simp

def inclusion_map_iso (x : X) : inclusion (f x) ‚ãô opens.map f ‚âÖ map f x ‚ãô inclusion x :=
nat_iso.of_components
  (Œª U, begin split, exact ùüô _, exact ùüô _ end)
  (by tidy)

@[simp] lemma inclusion_map_iso_hom (x : X) : (inclusion_map_iso f x).hom = ùüô _ := rfl
@[simp] lemma inclusion_map_iso_inv (x : X) : (inclusion_map_iso f x).inv = ùüô _ := rfl

end open_nhds
end topological_space
