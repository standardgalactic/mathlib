/-
Copyright (c) 2021 Justus Springer. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Justus Springer
-/

import category_theory.sites.spaces
import topology.sheaves.sheaf
import category_theory.sites.dense_subsite

/-!

# Coverings and sieves; from sheaves on sites and sheaves on spaces

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

In this file, we connect coverings in a topological space to sieves in the associated Grothendieck
topology, in preparation of connecting the sheaf condition on sites to the various sheaf conditions
on spaces.

We also specialize results about sheaves on sites to sheaves on spaces; we show that the inclusion
functor from a topological basis to `topological_space.opens` is cover_dense, that open maps
induce cover_preserving functors, and that open embeddings induce compatible_preserving functors.

-/

noncomputable theory

universes w v u

open category_theory topological_space

namespace Top.presheaf

variables {X : Top.{w}}

/--
Given a presieve `R` on `U`, we obtain a covering family of open sets in `X`, by taking as index
type the type of dependent pairs `(V, f)`, where `f : V ‚ü∂ U` is in `R`.
-/
def covering_of_presieve (U : opens X) (R : presieve U) : (Œ£ V, {f : V ‚ü∂ U // R f}) ‚Üí opens X :=
Œª f, f.1

@[simp]
lemma covering_of_presieve_apply (U : opens X) (R : presieve U) (f : Œ£ V, {f : V ‚ü∂ U // R f}) :
  covering_of_presieve U R f = f.1 := rfl

namespace covering_of_presieve

variables (U : opens X) (R : presieve U)

/--
If `R` is a presieve in the grothendieck topology on `opens X`, the covering family associated to
`R` really is _covering_, i.e. the union of all open sets equals `U`.
-/
lemma supr_eq_of_mem_grothendieck (hR : sieve.generate R ‚àà opens.grothendieck_topology X U) :
  supr (covering_of_presieve U R) = U :=
begin
  apply le_antisymm,
  { refine supr_le _,
    intro f,
    exact f.2.1.le, },
  intros x hxU,
  rw [opens.mem_supr],
  obtain ‚ü®V, iVU, ‚ü®W, iVW, iWU, hiWU, -‚ü©, hxV‚ü© := hR x hxU,
  exact ‚ü®‚ü®W, ‚ü®iWU, hiWU‚ü©‚ü©, iVW.le hxV‚ü©,
end

end covering_of_presieve

/--
Given a family of opens `U : Œπ ‚Üí opens X` and any open `Y : opens X`, we obtain a presieve
on `Y` by declaring that a morphism `f : V ‚ü∂ Y` is a member of the presieve if and only if
there exists an index `i : Œπ` such that `V = U i`.
-/
def presieve_of_covering_aux {Œπ : Type v} (U : Œπ ‚Üí opens X) (Y : opens X) : presieve Y :=
Œª V f, ‚àÉ i, V = U i

/-- Take `Y` to be `supr U` and obtain a presieve over `supr U`. -/
def presieve_of_covering {Œπ : Type v} (U : Œπ ‚Üí opens X) : presieve (supr U) :=
presieve_of_covering_aux U (supr U)

/-- Given a presieve `R` on `Y`, if we take its associated family of opens via
    `covering_of_presieve` (which may not cover `Y` if `R` is not covering), and take
    the presieve on `Y` associated to the family of opens via `presieve_of_covering_aux`,
    then we get back the original presieve `R`. -/
@[simp] lemma covering_presieve_eq_self {Y : opens X} (R : presieve Y) :
  presieve_of_covering_aux (covering_of_presieve Y R) Y = R :=
by { ext Z f, exact ‚ü®Œª ‚ü®‚ü®_,_,h‚ü©,rfl‚ü©, by convert h, Œª h, ‚ü®‚ü®Z,f,h‚ü©,rfl‚ü©‚ü© }

namespace presieve_of_covering

variables {Œπ : Type v} (U : Œπ ‚Üí opens X)

/--
The sieve generated by `presieve_of_covering U` is a member of the grothendieck topology.
-/
lemma mem_grothendieck_topology :
  sieve.generate (presieve_of_covering U) ‚àà opens.grothendieck_topology X (supr U) :=
begin
  intros x hx,
  obtain ‚ü®i, hxi‚ü© := opens.mem_supr.mp hx,
  exact ‚ü®U i, opens.le_supr U i, ‚ü®U i, ùüô _, opens.le_supr U i, ‚ü®i, rfl‚ü©, category.id_comp _‚ü©, hxi‚ü©,
end

/--
An index `i : Œπ` can be turned into a dependent pair `(V, f)`, where `V` is an open set and
`f : V ‚ü∂ supr U` is a member of `presieve_of_covering U f`.
-/
def hom_of_index (i : Œπ) : Œ£ V, {f : V ‚ü∂ supr U // presieve_of_covering U f} :=
‚ü®U i, opens.le_supr U i, i, rfl‚ü©

/--
By using the axiom of choice, a dependent pair `(V, f)` where `f : V ‚ü∂ supr U` is a member of
`presieve_of_covering U f` can be turned into an index `i : Œπ`, such that `V = U i`.
-/
def index_of_hom (f : Œ£ V, {f : V ‚ü∂ supr U // presieve_of_covering U f}) : Œπ := f.2.2.some

lemma index_of_hom_spec (f : Œ£ V, {f : V ‚ü∂ supr U // presieve_of_covering U f}) :
  f.1 = U (index_of_hom U f) := f.2.2.some_spec

end presieve_of_covering

end Top.presheaf

namespace Top.opens

variables {X : Top} {Œπ : Type*}

lemma cover_dense_iff_is_basis [category Œπ] (B : Œπ ‚•§ opens X) :
  cover_dense (opens.grothendieck_topology X) B ‚Üî opens.is_basis (set.range B.obj) :=
begin
  rw opens.is_basis_iff_nbhd,
  split, intros hd U x hx, rcases hd.1 U x hx with ‚ü®V,f,‚ü®i,f‚ÇÅ,f‚ÇÇ,hc‚ü©,hV‚ü©,
  exact ‚ü®B.obj i, ‚ü®i,rfl‚ü©, f‚ÇÅ.le hV, f‚ÇÇ.le‚ü©,
  intro hb, split, intros U x hx, rcases hb hx with ‚ü®_,‚ü®i,rfl‚ü©,hx,hi‚ü©,
  exact ‚ü®B.obj i, ‚ü®‚ü®hi‚ü©‚ü©, ‚ü®‚ü®i, ùüô _, ‚ü®‚ü®hi‚ü©‚ü©, rfl‚ü©‚ü©, hx‚ü©,
end

lemma cover_dense_induced_functor {B : Œπ ‚Üí opens X} (h : opens.is_basis (set.range B)) :
  cover_dense (opens.grothendieck_topology X) (induced_functor B) :=
(cover_dense_iff_is_basis _).2 h

end Top.opens

section open_embedding

open Top.presheaf opposite

variables {C : Type u} [category.{v} C]
variables {X Y : Top.{w}} {f : X ‚ü∂ Y} {F : Y.presheaf C}

lemma open_embedding.compatible_preserving (hf : open_embedding f) :
  compatible_preserving (opens.grothendieck_topology Y) hf.is_open_map.functor :=
begin
  haveI : mono f := (Top.mono_iff_injective f).mpr hf.inj,
  apply compatible_preserving_of_downwards_closed,
  intros U V i,
  refine ‚ü®(opens.map f).obj V, eq_to_iso $ opens.ext $ set.image_preimage_eq_of_subset $ Œª x h, _‚ü©,
  obtain ‚ü®_, _, rfl‚ü© := i.le h,
  exact ‚ü®_, rfl‚ü©
end

lemma is_open_map.cover_preserving (hf : is_open_map f) :
  cover_preserving (opens.grothendieck_topology X) (opens.grothendieck_topology Y) hf.functor :=
begin
  constructor,
  rintros U S hU _ ‚ü®x, hx, rfl‚ü©,
  obtain ‚ü®V, i, hV, hxV‚ü© := hU x hx,
  exact ‚ü®_, hf.functor.map i, ‚ü®_, i, ùüô _, hV, rfl‚ü©, set.mem_image_of_mem f hxV‚ü©
end

lemma Top.presheaf.is_sheaf_of_open_embedding (h : open_embedding f)
  (hF : F.is_sheaf) : is_sheaf (h.is_open_map.functor.op ‚ãô F) :=
pullback_is_sheaf_of_cover_preserving h.compatible_preserving h.is_open_map.cover_preserving ‚ü®_, hF‚ü©

end open_embedding

namespace Top.sheaf

open Top opposite

variables {C : Type u} [category.{v} C]
variables {X : Top.{w}} {Œπ : Type*} {B : Œπ ‚Üí opens X}
variables (F : X.presheaf C) (F' : sheaf C X) (h : opens.is_basis (set.range B))

/-- The empty component of a sheaf is terminal -/
def is_terminal_of_empty (F : sheaf C X) : limits.is_terminal (F.val.obj (op ‚ä•)) :=
F.is_terminal_of_bot_cover ‚ä• (by tidy)

/-- A variant of `is_terminal_of_empty` that is easier to `apply`. -/
def is_terminal_of_eq_empty (F : X.sheaf C) {U : opens X} (h : U = ‚ä•) :
  limits.is_terminal (F.val.obj (op U)) :=
by convert F.is_terminal_of_empty

/-- If a family `B` of open sets forms a basis of the topology on `X`, and if `F'`
    is a sheaf on `X`, then a homomorphism between a presheaf `F` on `X` and `F'`
    is equivalent to a homomorphism between their restrictions to the indexing type
    `Œπ` of `B`, with the induced category structure on `Œπ`. -/
def restrict_hom_equiv_hom :
  ((induced_functor B).op ‚ãô F ‚ü∂ (induced_functor B).op ‚ãô F'.1) ‚âÉ (F ‚ü∂ F'.1) :=
@cover_dense.restrict_hom_equiv_hom _ _ _ _ _ _ _ _ (opens.cover_dense_induced_functor h)
  _ F F'

@[simp] lemma extend_hom_app (Œ± : ((induced_functor B).op ‚ãô F ‚ü∂ (induced_functor B).op ‚ãô F'.1))
  (i : Œπ) : (restrict_hom_equiv_hom F F' h Œ±).app (op (B i)) = Œ±.app (op i) :=
by { nth_rewrite 1 ‚Üê (restrict_hom_equiv_hom F F' h).left_inv Œ±, refl }

include h
lemma hom_ext {Œ± Œ≤ : F ‚ü∂ F'.1} (he : ‚àÄ i, Œ±.app (op (B i)) = Œ≤.app (op (B i))) : Œ± = Œ≤ :=
by { apply (restrict_hom_equiv_hom F F' h).symm.injective, ext i, exact he i.unop }

end Top.sheaf
