/-
Copyright (c) 2019 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, Yury Kudryashov
-/
import analysis.normed.group.infinite_sum
import analysis.normed_space.basic
import topology.algebra.order.liminf_limsup
import topology.local_homeomorph

/-!
# Asymptotics

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We introduce these relations:

* `is_O_with c l f g` : "f is big O of g along l with constant c";
* `f =O[l] g` : "f is big O of g along l";
* `f =o[l] g` : "f is little o of g along l".

Here `l` is any filter on the domain of `f` and `g`, which are assumed to be the same. The codomains
of `f` and `g` do not need to be the same; all that is needed that there is a norm associated with
these types, and it is the norm that is compared asymptotically.

The relation `is_O_with c` is introduced to factor out common algebraic arguments in the proofs of
similar properties of `is_O` and `is_o`. Usually proofs outside of this file should use `is_O`
instead.

Often the ranges of `f` and `g` will be the real numbers, in which case the norm is the absolute
value. In general, we have

  `f =O[l] g ‚Üî (Œª x, ‚Äñf x‚Äñ) =O[l] (Œª x, ‚Äñg x‚Äñ)`,

and similarly for `is_o`. But our setup allows us to use the notions e.g. with functions
to the integers, rationals, complex numbers, or any normed vector space without mentioning the
norm explicitly.

If `f` and `g` are functions to a normed field like the reals or complex numbers and `g` is always
nonzero, we have

  `f =o[l] g ‚Üî tendsto (Œª x, f x / (g x)) l (ùìù 0)`.

In fact, the right-to-left direction holds without the hypothesis on `g`, and in the other direction
it suffices to assume that `f` is zero wherever `g` is. (This generalization is useful in defining
the Fr√©chet derivative.)
-/

open filter set
open_locale topology big_operators classical filter nnreal

namespace asymptotics

variables {Œ± : Type*} {Œ≤ : Type*} {E : Type*} {F : Type*} {G : Type*}
  {E' : Type*} {F' : Type*} {G' : Type*}
  {E'' : Type*} {F'' : Type*} {G'' : Type*}
  {R : Type*} {R' : Type*} {ùïú : Type*} {ùïú' : Type*}

variables [has_norm E] [has_norm F] [has_norm G]
variables [seminormed_add_comm_group E'] [seminormed_add_comm_group F']
  [seminormed_add_comm_group G'] [normed_add_comm_group E''] [normed_add_comm_group F'']
  [normed_add_comm_group G''] [semi_normed_ring R] [semi_normed_ring R']
variables [normed_field ùïú] [normed_field ùïú']
variables {c c' c‚ÇÅ c‚ÇÇ : ‚Ñù} {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {k : Œ± ‚Üí G}
variables {f' : Œ± ‚Üí E'} {g' : Œ± ‚Üí F'} {k' : Œ± ‚Üí G'}
variables {f'' : Œ± ‚Üí E''} {g'' : Œ± ‚Üí F''} {k'' : Œ± ‚Üí G''}
variables {l l' : filter Œ±}

section defs

/-! ### Definitions -/

/-- This version of the Landau notation `is_O_with C l f g` where `f` and `g` are two functions on
a type `Œ±` and `l` is a filter on `Œ±`, means that eventually for `l`, `‚Äñf‚Äñ` is bounded by `C * ‚Äñg‚Äñ`.
In other words, `‚Äñf‚Äñ / ‚Äñg‚Äñ` is eventually bounded by `C`, modulo division by zero issues that are
avoided by this definition. Probably you want to use `is_O` instead of this relation. -/
@[irreducible]
def is_O_with (c : ‚Ñù) (l : filter Œ±) (f : Œ± ‚Üí E) (g : Œ± ‚Üí F) : Prop :=
‚àÄ·∂† x in l, ‚Äñ f x ‚Äñ ‚â§ c * ‚Äñ g x ‚Äñ

/-- Definition of `is_O_with`. We record it in a lemma as `is_O_with` is irreducible. -/
lemma is_O_with_iff : is_O_with c l f g ‚Üî ‚àÄ·∂† x in l, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ := by rw is_O_with

alias is_O_with_iff ‚Üî is_O_with.bound is_O_with.of_bound

/-- The Landau notation `f =O[l] g` where `f` and `g` are two functions on a type `Œ±` and `l` is
a filter on `Œ±`, means that eventually for `l`, `‚Äñf‚Äñ` is bounded by a constant multiple of `‚Äñg‚Äñ`.
In other words, `‚Äñf‚Äñ / ‚Äñg‚Äñ` is eventually bounded, modulo division by zero issues that are avoided
by this definition. -/
@[irreducible]
def is_O (l : filter Œ±) (f : Œ± ‚Üí E) (g : Œ± ‚Üí F) : Prop := ‚àÉ c : ‚Ñù, is_O_with c l f g

notation f ` =O[`:100 l `] ` g:100 := is_O l f g

/-- Definition of `is_O` in terms of `is_O_with`. We record it in a lemma as `is_O` is
irreducible. -/
lemma is_O_iff_is_O_with : f =O[l] g ‚Üî ‚àÉ c : ‚Ñù, is_O_with c l f g := by rw is_O

/-- Definition of `is_O` in terms of filters. We record it in a lemma as we will set
`is_O` to be irreducible at the end of this file. -/
lemma is_O_iff : f =O[l] g ‚Üî ‚àÉ c : ‚Ñù, ‚àÄ·∂† x in l, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ :=
by simp only [is_O, is_O_with]

lemma is_O.of_bound (c : ‚Ñù) (h : ‚àÄ·∂† x in l, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : f =O[l] g :=
is_O_iff.2 ‚ü®c, h‚ü©

lemma is_O.of_bound' (h : ‚àÄ·∂† x in l, ‚Äñf x‚Äñ ‚â§ ‚Äñg x‚Äñ) : f =O[l] g :=
is_O.of_bound 1 $ by { simp_rw one_mul, exact h }

lemma is_O.bound : f =O[l] g ‚Üí ‚àÉ c : ‚Ñù, ‚àÄ·∂† x in l, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ := is_O_iff.1

/-- The Landau notation `f =o[l] g` where `f` and `g` are two functions on a type `Œ±` and `l` is
a filter on `Œ±`, means that eventually for `l`, `‚Äñf‚Äñ` is bounded by an arbitrarily small constant
multiple of `‚Äñg‚Äñ`. In other words, `‚Äñf‚Äñ / ‚Äñg‚Äñ` tends to `0` along `l`, modulo division by zero
issues that are avoided by this definition. -/
@[irreducible]
def is_o (l : filter Œ±) (f : Œ± ‚Üí E) (g : Œ± ‚Üí F) : Prop := ‚àÄ ‚¶Éc : ‚Ñù‚¶Ñ, 0 < c ‚Üí is_O_with c l f g

notation f ` =o[`:100 l `] ` g:100 := is_o l f g

/-- Definition of `is_o` in terms of `is_O_with`. We record it in a lemma as we will set
`is_o` to be irreducible at the end of this file. -/
lemma is_o_iff_forall_is_O_with : f =o[l] g ‚Üî ‚àÄ ‚¶Éc : ‚Ñù‚¶Ñ, 0 < c ‚Üí is_O_with c l f g := by rw is_o

alias is_o_iff_forall_is_O_with ‚Üî is_o.forall_is_O_with is_o.of_is_O_with

/-- Definition of `is_o` in terms of filters. We record it in a lemma as we will set
`is_o` to be irreducible at the end of this file. -/
lemma is_o_iff : f =o[l] g ‚Üî ‚àÄ ‚¶Éc : ‚Ñù‚¶Ñ, 0 < c ‚Üí ‚àÄ·∂† x in l, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ :=
by simp only [is_o, is_O_with]

alias is_o_iff ‚Üî is_o.bound is_o.of_bound

lemma is_o.def (h : f =o[l] g) (hc : 0 < c) : ‚àÄ·∂† x in l, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ :=
is_o_iff.1 h hc

lemma is_o.def' (h : f =o[l] g) (hc : 0 < c) : is_O_with c l f g :=
is_O_with_iff.2 $ is_o_iff.1 h hc

end defs

/-! ### Conversions -/

theorem is_O_with.is_O (h : is_O_with c l f g) : f =O[l] g := by rw is_O; exact ‚ü®c, h‚ü©

theorem is_o.is_O_with (hgf : f =o[l] g) : is_O_with 1 l f g := hgf.def' zero_lt_one

theorem is_o.is_O (hgf : f =o[l] g) : f =O[l] g := hgf.is_O_with.is_O

lemma is_O.is_O_with : f =O[l] g ‚Üí ‚àÉ c : ‚Ñù, is_O_with c l f g := is_O_iff_is_O_with.1

theorem is_O_with.weaken (h : is_O_with c l f g') (hc : c ‚â§ c') : is_O_with c' l f g' :=
is_O_with.of_bound $ mem_of_superset h.bound $ Œª x hx,
calc ‚Äñf x‚Äñ ‚â§ c * ‚Äñg' x‚Äñ : hx
... ‚â§ _ : mul_le_mul_of_nonneg_right hc (norm_nonneg _)

theorem is_O_with.exists_pos (h : is_O_with c l f g') :
  ‚àÉ c' (H : 0 < c'), is_O_with c' l f g' :=
‚ü®max c 1, lt_of_lt_of_le zero_lt_one (le_max_right c 1), h.weaken $ le_max_left c 1‚ü©

theorem is_O.exists_pos (h : f =O[l] g') : ‚àÉ c (H : 0 < c), is_O_with c l f g' :=
let ‚ü®c, hc‚ü© := h.is_O_with in hc.exists_pos

theorem is_O_with.exists_nonneg (h : is_O_with c l f g') :
  ‚àÉ c' (H : 0 ‚â§ c'), is_O_with c' l f g' :=
let ‚ü®c, cpos, hc‚ü© := h.exists_pos in ‚ü®c, le_of_lt cpos, hc‚ü©

theorem is_O.exists_nonneg (h : f =O[l] g') :
  ‚àÉ c (H : 0 ‚â§ c), is_O_with c l f g' :=
let ‚ü®c, hc‚ü© := h.is_O_with in hc.exists_nonneg

/-- `f = O(g)` if and only if `is_O_with c f g` for all sufficiently large `c`. -/
lemma is_O_iff_eventually_is_O_with : f =O[l] g' ‚Üî ‚àÄ·∂† c in at_top, is_O_with c l f g' :=
is_O_iff_is_O_with.trans
  ‚ü®Œª ‚ü®c, hc‚ü©, mem_at_top_sets.2 ‚ü®c, Œª c' hc', hc.weaken hc'‚ü©, Œª h, h.exists‚ü©

/-- `f = O(g)` if and only if `‚àÄ·∂† x in l, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ` for all sufficiently large `c`. -/
lemma is_O_iff_eventually : f =O[l] g' ‚Üî ‚àÄ·∂† c in at_top, ‚àÄ·∂† x in l, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg' x‚Äñ :=
is_O_iff_eventually_is_O_with.trans $ by simp only [is_O_with]

lemma is_O.exists_mem_basis {Œπ} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí set Œ±} (h : f =O[l] g')
  (hb : l.has_basis p s) :
  ‚àÉ (c : ‚Ñù) (hc : 0 < c) (i : Œπ) (hi : p i), ‚àÄ x ‚àà s i, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg' x‚Äñ :=
flip Exists‚ÇÇ.imp h.exists_pos $ Œª c hc h,
  by simpa only [is_O_with_iff, hb.eventually_iff, exists_prop] using h

lemma is_O_with_inv (hc : 0 < c) : is_O_with c‚Åª¬π l f g ‚Üî ‚àÄ·∂† x in l, c * ‚Äñf x‚Äñ ‚â§ ‚Äñg x‚Äñ :=
by simp only [is_O_with, ‚Üê div_eq_inv_mul, le_div_iff' hc]

-- We prove this lemma with strange assumptions to get two lemmas below automatically
lemma is_o_iff_nat_mul_le_aux (h‚ÇÄ : (‚àÄ x, 0 ‚â§ ‚Äñf x‚Äñ) ‚à® ‚àÄ x, 0 ‚â§ ‚Äñg x‚Äñ) :
  f =o[l] g ‚Üî ‚àÄ n : ‚Ñï, ‚àÄ·∂† x in l, ‚Üën * ‚Äñf x‚Äñ ‚â§ ‚Äñg x‚Äñ :=
begin
  split,
  { rintro H (_|n),
    { refine (H.def one_pos).mono (Œª x h‚ÇÄ', _),
      rw [nat.cast_zero, zero_mul],
      refine h‚ÇÄ.elim (Œª hf, (hf x).trans _) (Œª hg, hg x),
      rwa one_mul at h‚ÇÄ' },
    { have : (0 : ‚Ñù) < n.succ, from nat.cast_pos.2 n.succ_pos,
      exact (is_O_with_inv this).1 (H.def' $ inv_pos.2 this) } },
  { refine Œª H, is_o_iff.2 (Œª Œµ Œµ0, _),
    rcases exists_nat_gt Œµ‚Åª¬π with ‚ü®n, hn‚ü©,
    have hn‚ÇÄ : (0 : ‚Ñù) < n, from (inv_pos.2 Œµ0).trans hn,
    refine ((is_O_with_inv hn‚ÇÄ).2 (H n)).bound.mono (Œª x hfg, _),
    refine hfg.trans (mul_le_mul_of_nonneg_right (inv_le_of_inv_le Œµ0 hn.le) _),
    refine h‚ÇÄ.elim (Œª hf, nonneg_of_mul_nonneg_right ((hf x).trans hfg) _) (Œª h, h x),
    exact inv_pos.2 hn‚ÇÄ }
end

lemma is_o_iff_nat_mul_le : f =o[l] g' ‚Üî ‚àÄ n : ‚Ñï, ‚àÄ·∂† x in l, ‚Üën * ‚Äñf x‚Äñ ‚â§ ‚Äñg' x‚Äñ :=
is_o_iff_nat_mul_le_aux (or.inr $ Œª x, norm_nonneg _)

lemma is_o_iff_nat_mul_le' : f' =o[l] g ‚Üî ‚àÄ n : ‚Ñï, ‚àÄ·∂† x in l, ‚Üën * ‚Äñf' x‚Äñ ‚â§ ‚Äñg x‚Äñ :=
is_o_iff_nat_mul_le_aux (or.inl $ Œª x, norm_nonneg _)

/-! ### Subsingleton -/

@[nontriviality] lemma is_o_of_subsingleton [subsingleton E'] : f' =o[l] g' :=
is_o.of_bound $ Œª c hc, by simp [subsingleton.elim (f' _) 0, mul_nonneg hc.le]

@[nontriviality] lemma is_O_of_subsingleton [subsingleton E'] : f' =O[l] g' :=
is_o_of_subsingleton.is_O

section congr

variables {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí F}

/-! ### Congruence -/

theorem is_O_with_congr (hc : c‚ÇÅ = c‚ÇÇ) (hf : f‚ÇÅ =·∂†[l] f‚ÇÇ) (hg : g‚ÇÅ =·∂†[l] g‚ÇÇ) :
  is_O_with c‚ÇÅ l f‚ÇÅ g‚ÇÅ ‚Üî is_O_with c‚ÇÇ l f‚ÇÇ g‚ÇÇ :=
begin
  unfold is_O_with,
  subst c‚ÇÇ,
  apply filter.eventually_congr,
  filter_upwards [hf, hg] with _ e‚ÇÅ e‚ÇÇ,
  rw [e‚ÇÅ, e‚ÇÇ],
end

theorem is_O_with.congr' (h : is_O_with c‚ÇÅ l f‚ÇÅ g‚ÇÅ) (hc : c‚ÇÅ = c‚ÇÇ) (hf : f‚ÇÅ =·∂†[l] f‚ÇÇ)
  (hg : g‚ÇÅ =·∂†[l] g‚ÇÇ) : is_O_with c‚ÇÇ l f‚ÇÇ g‚ÇÇ :=
(is_O_with_congr hc hf hg).mp h

theorem is_O_with.congr (h : is_O_with c‚ÇÅ l f‚ÇÅ g‚ÇÅ) (hc : c‚ÇÅ = c‚ÇÇ) (hf : ‚àÄ x, f‚ÇÅ x = f‚ÇÇ x)
  (hg : ‚àÄ x, g‚ÇÅ x = g‚ÇÇ x) : is_O_with c‚ÇÇ l f‚ÇÇ g‚ÇÇ :=
h.congr' hc (univ_mem' hf) (univ_mem' hg)

theorem is_O_with.congr_left (h : is_O_with c l f‚ÇÅ g) (hf : ‚àÄ x, f‚ÇÅ x = f‚ÇÇ x) :
  is_O_with c l f‚ÇÇ g :=
h.congr rfl hf (Œª _, rfl)

theorem is_O_with.congr_right (h : is_O_with c l f g‚ÇÅ) (hg : ‚àÄ x, g‚ÇÅ x = g‚ÇÇ x) :
  is_O_with c l f g‚ÇÇ :=
h.congr rfl (Œª _, rfl) hg

theorem is_O_with.congr_const (h : is_O_with c‚ÇÅ l f g) (hc : c‚ÇÅ = c‚ÇÇ) : is_O_with c‚ÇÇ l f g :=
h.congr hc (Œª _, rfl) (Œª _, rfl)

theorem is_O_congr (hf : f‚ÇÅ =·∂†[l] f‚ÇÇ) (hg : g‚ÇÅ =·∂†[l] g‚ÇÇ) : f‚ÇÅ =O[l] g‚ÇÅ ‚Üî f‚ÇÇ =O[l] g‚ÇÇ :=
by { unfold is_O, exact exists_congr (Œª c, is_O_with_congr rfl hf hg) }

theorem is_O.congr' (h : f‚ÇÅ =O[l] g‚ÇÅ) (hf : f‚ÇÅ =·∂†[l] f‚ÇÇ) (hg : g‚ÇÅ =·∂†[l] g‚ÇÇ) : f‚ÇÇ =O[l] g‚ÇÇ :=
(is_O_congr hf hg).mp h

theorem is_O.congr (h : f‚ÇÅ =O[l] g‚ÇÅ) (hf : ‚àÄ x, f‚ÇÅ x = f‚ÇÇ x) (hg : ‚àÄ x, g‚ÇÅ x = g‚ÇÇ x) :
  f‚ÇÇ =O[l] g‚ÇÇ :=
h.congr' (univ_mem' hf) (univ_mem' hg)

theorem is_O.congr_left (h : f‚ÇÅ =O[l] g) (hf : ‚àÄ x, f‚ÇÅ x = f‚ÇÇ x) : f‚ÇÇ =O[l] g :=
h.congr hf (Œª _, rfl)

theorem is_O.congr_right (h : f =O[l] g‚ÇÅ) (hg : ‚àÄ x, g‚ÇÅ x = g‚ÇÇ x) : f =O[l] g‚ÇÇ :=
h.congr (Œª _, rfl) hg

theorem is_o_congr (hf : f‚ÇÅ =·∂†[l] f‚ÇÇ) (hg : g‚ÇÅ =·∂†[l] g‚ÇÇ) : f‚ÇÅ =o[l] g‚ÇÅ ‚Üî f‚ÇÇ =o[l] g‚ÇÇ :=
by { unfold is_o, exact forall‚ÇÇ_congr (Œª c hc, is_O_with_congr (eq.refl c) hf hg) }

theorem is_o.congr' (h : f‚ÇÅ =o[l] g‚ÇÅ) (hf : f‚ÇÅ =·∂†[l] f‚ÇÇ) (hg : g‚ÇÅ =·∂†[l] g‚ÇÇ) : f‚ÇÇ =o[l] g‚ÇÇ :=
(is_o_congr hf hg).mp h

theorem is_o.congr (h : f‚ÇÅ =o[l] g‚ÇÅ) (hf : ‚àÄ x, f‚ÇÅ x = f‚ÇÇ x) (hg : ‚àÄ x, g‚ÇÅ x = g‚ÇÇ x) :
  f‚ÇÇ =o[l] g‚ÇÇ :=
h.congr' (univ_mem' hf) (univ_mem' hg)

theorem is_o.congr_left (h : f‚ÇÅ =o[l] g) (hf : ‚àÄ x, f‚ÇÅ x = f‚ÇÇ x) : f‚ÇÇ =o[l] g :=
h.congr hf (Œª _, rfl)

theorem is_o.congr_right (h : f =o[l] g‚ÇÅ) (hg : ‚àÄ x, g‚ÇÅ x = g‚ÇÇ x) : f =o[l] g‚ÇÇ :=
h.congr (Œª _, rfl) hg

@[trans] theorem _root_.filter.eventually_eq.trans_is_O {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E} {g : Œ± ‚Üí F}
  (hf : f‚ÇÅ =·∂†[l] f‚ÇÇ) (h : f‚ÇÇ =O[l] g) : f‚ÇÅ =O[l] g :=
h.congr' hf.symm eventually_eq.rfl

@[trans] theorem _root_.filter.eventually_eq.trans_is_o {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E} {g : Œ± ‚Üí F}
  (hf : f‚ÇÅ =·∂†[l] f‚ÇÇ) (h : f‚ÇÇ =o[l] g) : f‚ÇÅ =o[l] g :=
h.congr' hf.symm eventually_eq.rfl

@[trans] theorem is_O.trans_eventually_eq {f : Œ± ‚Üí E} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí F}
  (h : f =O[l] g‚ÇÅ) (hg : g‚ÇÅ =·∂†[l] g‚ÇÇ) : f =O[l] g‚ÇÇ :=
h.congr' eventually_eq.rfl hg

@[trans] theorem is_o.trans_eventually_eq {f : Œ± ‚Üí E} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí F}
  (h : f =o[l] g‚ÇÅ) (hg : g‚ÇÅ =·∂†[l] g‚ÇÇ) : f =o[l] g‚ÇÇ :=
h.congr' eventually_eq.rfl hg

end congr

/-! ### Filter operations and transitivity -/

theorem is_O_with.comp_tendsto (hcfg : is_O_with c l f g)
  {k : Œ≤ ‚Üí Œ±} {l' : filter Œ≤} (hk : tendsto k l' l):
  is_O_with c l' (f ‚àò k) (g ‚àò k) :=
is_O_with.of_bound $ hk hcfg.bound

theorem is_O.comp_tendsto (hfg : f =O[l] g) {k : Œ≤ ‚Üí Œ±} {l' : filter Œ≤} (hk : tendsto k l' l) :
  (f ‚àò k) =O[l'] (g ‚àò k) :=
is_O_iff_is_O_with.2 $ hfg.is_O_with.imp (Œª c h, h.comp_tendsto hk)

theorem is_o.comp_tendsto (hfg : f =o[l] g) {k : Œ≤ ‚Üí Œ±} {l' : filter Œ≤} (hk : tendsto k l' l) :
  (f ‚àò k) =o[l'] (g ‚àò k) :=
is_o.of_is_O_with $ Œª c cpos, (hfg.forall_is_O_with cpos).comp_tendsto hk

@[simp] theorem is_O_with_map {k : Œ≤ ‚Üí Œ±} {l : filter Œ≤} :
  is_O_with c (map k l) f g ‚Üî is_O_with c l (f ‚àò k) (g ‚àò k) :=
by { unfold is_O_with, exact eventually_map }

@[simp] theorem is_O_map {k : Œ≤ ‚Üí Œ±} {l : filter Œ≤} : f =O[map k l] g ‚Üî (f ‚àò k) =O[l] (g ‚àò k) :=
by simp only [is_O, is_O_with_map]

@[simp] theorem is_o_map {k : Œ≤ ‚Üí Œ±} {l : filter Œ≤} : f =o[map k l] g ‚Üî (f ‚àò k) =o[l] (g ‚àò k) :=
by simp only [is_o, is_O_with_map]

theorem is_O_with.mono (h : is_O_with c l' f g) (hl : l ‚â§ l') : is_O_with c l f g :=
is_O_with.of_bound $ hl h.bound

theorem is_O.mono (h : f =O[l'] g) (hl : l ‚â§ l') : f =O[l] g :=
is_O_iff_is_O_with.2 $ h.is_O_with.imp (Œª c h, h.mono hl)

theorem is_o.mono (h : f =o[l'] g) (hl : l ‚â§ l') : f =o[l] g :=
is_o.of_is_O_with $ Œª c cpos, (h.forall_is_O_with cpos).mono hl

theorem is_O_with.trans (hfg : is_O_with c l f g) (hgk : is_O_with c' l g k) (hc : 0 ‚â§ c) :
  is_O_with (c * c') l f k :=
begin
  unfold is_O_with at *,
  filter_upwards [hfg, hgk] with x hx hx',
  calc ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ : hx
  ... ‚â§ c * (c' * ‚Äñk x‚Äñ) : mul_le_mul_of_nonneg_left hx' hc
  ... = c * c' * ‚Äñk x‚Äñ : (mul_assoc _ _ _).symm
end

@[trans] theorem is_O.trans {f : Œ± ‚Üí E} {g : Œ± ‚Üí F'} {k : Œ± ‚Üí G} (hfg : f =O[l] g)
  (hgk : g =O[l] k) : f =O[l] k :=
let ‚ü®c, cnonneg, hc‚ü© := hfg.exists_nonneg, ‚ü®c', hc'‚ü© := hgk.is_O_with in
(hc.trans hc' cnonneg).is_O

theorem is_o.trans_is_O_with (hfg : f =o[l] g) (hgk : is_O_with c l g k) (hc : 0 < c) :
  f =o[l] k :=
begin
  unfold is_o at *,
  intros c' c'pos,
  have : 0 < c' / c, from div_pos c'pos hc,
  exact ((hfg this).trans hgk this.le).congr_const (div_mul_cancel _ hc.ne')
end

@[trans] theorem is_o.trans_is_O {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {k : Œ± ‚Üí G'} (hfg : f =o[l] g)
  (hgk : g =O[l] k) :
  f =o[l] k :=
let ‚ü®c, cpos, hc‚ü© := hgk.exists_pos in hfg.trans_is_O_with hc cpos

theorem is_O_with.trans_is_o (hfg : is_O_with c l f g) (hgk : g =o[l] k) (hc : 0 < c) :
  f =o[l] k :=
begin
  unfold is_o at *,
  intros c' c'pos,
  have : 0 < c' / c, from div_pos c'pos hc,
  exact (hfg.trans (hgk this) hc.le).congr_const (mul_div_cancel' _ hc.ne')
end

@[trans] theorem is_O.trans_is_o {f : Œ± ‚Üí E} {g : Œ± ‚Üí F'} {k : Œ± ‚Üí G} (hfg : f =O[l] g)
  (hgk : g =o[l] k) :
  f =o[l] k :=
let ‚ü®c, cpos, hc‚ü© := hfg.exists_pos in hc.trans_is_o hgk cpos

@[trans] theorem is_o.trans {f : Œ± ‚Üí E} {g : Œ± ‚Üí F} {k : Œ± ‚Üí G} (hfg : f =o[l] g)
  (hgk : g =o[l] k) : f =o[l] k :=
hfg.trans_is_O_with hgk.is_O_with one_pos

lemma _root_.filter.eventually.trans_is_O {f : Œ± ‚Üí E} {g : Œ± ‚Üí F'} {k : Œ± ‚Üí G}
  (hfg : ‚àÄ·∂† x in l, ‚Äñf x‚Äñ ‚â§ ‚Äñg x‚Äñ) (hgk : g =O[l] k) : f =O[l] k :=
(is_O.of_bound' hfg).trans hgk

lemma _root_.filter.eventually.is_O {f : Œ± ‚Üí E} {g : Œ± ‚Üí ‚Ñù} {l : filter Œ±}
  (hfg : ‚àÄ·∂† x in l, ‚Äñf x‚Äñ ‚â§ g x) : f =O[l] g :=
is_O.of_bound' $ hfg.mono $ Œª x hx, hx.trans $ real.le_norm_self _

section

variable (l)

theorem is_O_with_of_le' (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : is_O_with c l f g :=
is_O_with.of_bound $ univ_mem' hfg

theorem is_O_with_of_le (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ ‚Äñg x‚Äñ) : is_O_with 1 l f g :=
is_O_with_of_le' l $ Œª x, by { rw one_mul, exact hfg x }

theorem is_O_of_le' (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ) : f =O[l] g :=
(is_O_with_of_le' l hfg).is_O

theorem is_O_of_le (hfg : ‚àÄ x, ‚Äñf x‚Äñ ‚â§ ‚Äñg x‚Äñ) : f =O[l] g :=
(is_O_with_of_le l hfg).is_O

end

theorem is_O_with_refl (f : Œ± ‚Üí E) (l : filter Œ±) : is_O_with 1 l f f :=
is_O_with_of_le l $ Œª _, le_rfl

theorem is_O_refl (f : Œ± ‚Üí E) (l : filter Œ±) : f =O[l] f := (is_O_with_refl f l).is_O

theorem is_O_with.trans_le (hfg : is_O_with c l f g) (hgk : ‚àÄ x, ‚Äñg x‚Äñ ‚â§ ‚Äñk x‚Äñ) (hc : 0 ‚â§ c) :
  is_O_with c l f k :=
(hfg.trans (is_O_with_of_le l hgk) hc).congr_const $ mul_one c

theorem is_O.trans_le (hfg : f =O[l] g') (hgk : ‚àÄ x, ‚Äñg' x‚Äñ ‚â§ ‚Äñk x‚Äñ) : f =O[l] k :=
hfg.trans (is_O_of_le l hgk)

theorem is_o.trans_le (hfg : f =o[l] g) (hgk : ‚àÄ x, ‚Äñg x‚Äñ ‚â§ ‚Äñk x‚Äñ) : f =o[l] k :=
hfg.trans_is_O_with (is_O_with_of_le _ hgk) zero_lt_one

theorem is_o_irrefl' (h : ‚àÉ·∂† x in l, ‚Äñf' x‚Äñ ‚â† 0) : ¬¨f' =o[l] f' :=
begin
  intro ho,
  rcases ((ho.bound one_half_pos).and_frequently h).exists with ‚ü®x, hle, hne‚ü©,
  rw [one_div, ‚Üê div_eq_inv_mul] at hle,
  exact (half_lt_self (lt_of_le_of_ne (norm_nonneg _) hne.symm)).not_le hle
end

theorem is_o_irrefl (h : ‚àÉ·∂† x in l, f'' x ‚â† 0) : ¬¨f'' =o[l] f'' :=
is_o_irrefl' $ h.mono $ Œª x, norm_ne_zero_iff.mpr

theorem is_O.not_is_o (h : f'' =O[l] g') (hf : ‚àÉ·∂† x in l, f'' x ‚â† 0) : ¬¨g' =o[l] f'' :=
Œª h', is_o_irrefl hf (h.trans_is_o h')

theorem is_o.not_is_O (h : f'' =o[l] g') (hf : ‚àÉ·∂† x in l, f'' x ‚â† 0) : ¬¨g' =O[l] f'' :=
Œª h', is_o_irrefl hf (h.trans_is_O h')

section bot

variables (c f g)

@[simp] theorem is_O_with_bot : is_O_with c ‚ä• f g := is_O_with.of_bound $ trivial

@[simp] theorem is_O_bot : f =O[‚ä•] g := (is_O_with_bot 1 f g).is_O

@[simp] theorem is_o_bot : f =o[‚ä•] g := is_o.of_is_O_with $ Œª c _, is_O_with_bot c f g

end bot

@[simp] theorem is_O_with_pure {x} : is_O_with c (pure x) f g ‚Üî ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ := is_O_with_iff

theorem is_O_with.sup (h : is_O_with c l f g) (h' : is_O_with c l' f g) :
  is_O_with c (l ‚äî l') f g :=
is_O_with.of_bound $ mem_sup.2 ‚ü®h.bound, h'.bound‚ü©

theorem is_O_with.sup' (h : is_O_with c l f g') (h' : is_O_with c' l' f g') :
  is_O_with (max c c') (l ‚äî l') f g' :=
is_O_with.of_bound $
mem_sup.2 ‚ü®(h.weaken $ le_max_left c c').bound, (h'.weaken $ le_max_right c c').bound‚ü©

theorem is_O.sup (h : f =O[l] g') (h' : f =O[l'] g') : f =O[l ‚äî l'] g' :=
let ‚ü®c, hc‚ü© := h.is_O_with, ‚ü®c', hc'‚ü© := h'.is_O_with in (hc.sup' hc').is_O

theorem is_o.sup (h : f =o[l] g) (h' : f =o[l'] g) : f =o[l ‚äî l'] g :=
is_o.of_is_O_with $ Œª c cpos, (h.forall_is_O_with cpos).sup (h'.forall_is_O_with cpos)

@[simp] lemma is_O_sup : f =O[l ‚äî l'] g' ‚Üî f =O[l] g' ‚àß f =O[l'] g' :=
‚ü®Œª h, ‚ü®h.mono le_sup_left, h.mono le_sup_right‚ü©, Œª h, h.1.sup h.2‚ü©

@[simp] lemma is_o_sup : f =o[l ‚äî l'] g ‚Üî f =o[l] g ‚àß f =o[l'] g :=
‚ü®Œª h, ‚ü®h.mono le_sup_left, h.mono le_sup_right‚ü©, Œª h, h.1.sup h.2‚ü©

lemma is_O_with_insert [topological_space Œ±] {x : Œ±} {s : set Œ±} {C : ‚Ñù} {g : Œ± ‚Üí E} {g' : Œ± ‚Üí F}
  (h : ‚Äñg x‚Äñ ‚â§ C * ‚Äñg' x‚Äñ) :
  is_O_with C (ùìù[insert x s] x) g g' ‚Üî is_O_with C (ùìù[s] x) g g' :=
by simp_rw [is_O_with, nhds_within_insert, eventually_sup, eventually_pure, h, true_and]

lemma is_O_with.insert [topological_space Œ±] {x : Œ±} {s : set Œ±} {C : ‚Ñù} {g : Œ± ‚Üí E} {g' : Œ± ‚Üí F}
  (h1 : is_O_with C (ùìù[s] x) g g') (h2 : ‚Äñg x‚Äñ ‚â§ C * ‚Äñg' x‚Äñ) :
  is_O_with C (ùìù[insert x s] x) g g' :=
(is_O_with_insert h2).mpr h1

lemma is_o_insert [topological_space Œ±] {x : Œ±} {s : set Œ±} {g : Œ± ‚Üí E'} {g' : Œ± ‚Üí F'}
  (h : g x = 0) : g =o[ùìù[insert x s] x] g' ‚Üî g =o[ùìù[s] x] g' :=
begin
  simp_rw [is_o],
  refine forall_congr (Œª c, forall_congr (Œª hc, _)),
  rw [is_O_with_insert],
  rw [h, norm_zero],
  exact mul_nonneg hc.le (norm_nonneg _)
end

lemma is_o.insert [topological_space Œ±] {x : Œ±} {s : set Œ±} {g : Œ± ‚Üí E'} {g' : Œ± ‚Üí F'}
  (h1 : g =o[ùìù[s] x] g') (h2 : g x = 0) : g =o[ùìù[insert x s] x] g' :=
(is_o_insert h2).mpr h1

/-! ### Simplification : norm, abs -/

section norm_abs

variables {u v : Œ± ‚Üí ‚Ñù}

@[simp] theorem is_O_with_norm_right : is_O_with c l f (Œª x, ‚Äñg' x‚Äñ) ‚Üî is_O_with c l f g' :=
by simp only [is_O_with, norm_norm]

@[simp] theorem is_O_with_abs_right : is_O_with c l f (Œª x, |u x|) ‚Üî is_O_with c l f u :=
@is_O_with_norm_right _ _ _ _ _ _ f u l

alias is_O_with_norm_right ‚Üî is_O_with.of_norm_right is_O_with.norm_right
alias is_O_with_abs_right ‚Üî is_O_with.of_abs_right is_O_with.abs_right

@[simp] theorem is_O_norm_right : f =O[l] (Œª x, ‚Äñg' x‚Äñ) ‚Üî f =O[l] g' :=
by { unfold is_O, exact exists_congr (Œª _, is_O_with_norm_right) }

@[simp] theorem is_O_abs_right : f =O[l] (Œª x, |u x|) ‚Üî f =O[l] u :=
@is_O_norm_right _ _ ‚Ñù _ _ _ _ _

alias is_O_norm_right ‚Üî is_O.of_norm_right is_O.norm_right
alias is_O_abs_right ‚Üî is_O.of_abs_right is_O.abs_right

@[simp] theorem is_o_norm_right : f =o[l] (Œª x, ‚Äñg' x‚Äñ) ‚Üî f =o[l] g' :=
by { unfold is_o, exact forall‚ÇÇ_congr (Œª _ _, is_O_with_norm_right) }

@[simp] theorem is_o_abs_right : f =o[l] (Œª x, |u x|) ‚Üî f =o[l] u :=
@is_o_norm_right _ _ ‚Ñù _ _ _ _ _

alias is_o_norm_right ‚Üî is_o.of_norm_right is_o.norm_right
alias is_o_abs_right ‚Üî is_o.of_abs_right is_o.abs_right

@[simp] theorem is_O_with_norm_left : is_O_with c l (Œª x, ‚Äñf' x‚Äñ) g ‚Üî is_O_with c l f' g :=
by simp only [is_O_with, norm_norm]

@[simp] theorem is_O_with_abs_left : is_O_with c l (Œª x, |u x|) g ‚Üî is_O_with c l u g :=
@is_O_with_norm_left _ _ _ _ _ _ g u l

alias is_O_with_norm_left ‚Üî is_O_with.of_norm_left is_O_with.norm_left
alias is_O_with_abs_left ‚Üî is_O_with.of_abs_left is_O_with.abs_left

@[simp] theorem is_O_norm_left : (Œª x, ‚Äñf' x‚Äñ) =O[l] g ‚Üî f' =O[l] g :=
by { unfold is_O, exact exists_congr (Œª _, is_O_with_norm_left) }

@[simp] theorem is_O_abs_left : (Œª x, |u x|) =O[l] g ‚Üî u =O[l] g :=
@is_O_norm_left _ _ _ _ _ g u l

alias is_O_norm_left ‚Üî is_O.of_norm_left is_O.norm_left
alias is_O_abs_left ‚Üî is_O.of_abs_left is_O.abs_left

@[simp] theorem is_o_norm_left : (Œª x, ‚Äñf' x‚Äñ) =o[l] g ‚Üî f' =o[l] g :=
by { unfold is_o, exact forall‚ÇÇ_congr (Œª _ _, is_O_with_norm_left) }

@[simp] theorem is_o_abs_left : (Œª x, |u x|) =o[l] g ‚Üî u =o[l] g :=
@is_o_norm_left _ _ _ _ _ g u l

alias is_o_norm_left ‚Üî is_o.of_norm_left is_o.norm_left
alias is_o_abs_left ‚Üî is_o.of_abs_left is_o.abs_left

theorem is_O_with_norm_norm : is_O_with c l (Œª x, ‚Äñf' x‚Äñ) (Œª x, ‚Äñg' x‚Äñ) ‚Üî is_O_with c l f' g' :=
is_O_with_norm_left.trans is_O_with_norm_right

theorem is_O_with_abs_abs : is_O_with c l (Œª x, |u x|) (Œª x, |v x|) ‚Üî is_O_with c l u v :=
is_O_with_abs_left.trans is_O_with_abs_right

alias is_O_with_norm_norm ‚Üî is_O_with.of_norm_norm is_O_with.norm_norm
alias is_O_with_abs_abs ‚Üî is_O_with.of_abs_abs is_O_with.abs_abs

theorem is_O_norm_norm : (Œª x, ‚Äñf' x‚Äñ) =O[l] (Œª x, ‚Äñg' x‚Äñ) ‚Üî f' =O[l] g' :=
is_O_norm_left.trans is_O_norm_right

theorem is_O_abs_abs : (Œª x, |u x|) =O[l] (Œª x, |v x|) ‚Üî u =O[l] v :=
is_O_abs_left.trans is_O_abs_right

alias is_O_norm_norm ‚Üî is_O.of_norm_norm is_O.norm_norm
alias is_O_abs_abs ‚Üî is_O.of_abs_abs is_O.abs_abs

theorem is_o_norm_norm : (Œª x, ‚Äñf' x‚Äñ) =o[l] (Œª x, ‚Äñg' x‚Äñ) ‚Üî f' =o[l] g' :=
is_o_norm_left.trans is_o_norm_right

theorem is_o_abs_abs : (Œª x, |u x|) =o[l] (Œª x, |v x|) ‚Üî u =o[l] v :=
is_o_abs_left.trans is_o_abs_right

alias is_o_norm_norm ‚Üî is_o.of_norm_norm is_o.norm_norm
alias is_o_abs_abs ‚Üî is_o.of_abs_abs is_o.abs_abs

end norm_abs

/-! ### Simplification: negate -/

@[simp] theorem is_O_with_neg_right : is_O_with c l f (Œª x, -(g' x)) ‚Üî is_O_with c l f g' :=
by simp only [is_O_with, norm_neg]

alias is_O_with_neg_right ‚Üî is_O_with.of_neg_right is_O_with.neg_right

@[simp] theorem is_O_neg_right : f =O[l] (Œª x, -(g' x)) ‚Üî f =O[l] g' :=
by { unfold is_O, exact exists_congr (Œª _, is_O_with_neg_right) }

alias is_O_neg_right ‚Üî is_O.of_neg_right is_O.neg_right

@[simp] theorem is_o_neg_right : f =o[l] (Œª x, -(g' x)) ‚Üî f =o[l] g' :=
by { unfold is_o, exact forall‚ÇÇ_congr (Œª _ _, is_O_with_neg_right) }

alias is_o_neg_right ‚Üî is_o.of_neg_right is_o.neg_right

@[simp] theorem is_O_with_neg_left : is_O_with c l (Œª x, -(f' x)) g ‚Üî is_O_with c l f' g :=
by simp only [is_O_with, norm_neg]

alias is_O_with_neg_left ‚Üî is_O_with.of_neg_left is_O_with.neg_left

@[simp] theorem is_O_neg_left : (Œª x, -(f' x)) =O[l] g ‚Üî f' =O[l] g :=
by { unfold is_O, exact exists_congr (Œª _, is_O_with_neg_left) }

alias is_O_neg_left ‚Üî is_O.of_neg_left is_O.neg_left

@[simp] theorem is_o_neg_left : (Œª x, -(f' x)) =o[l] g ‚Üî f' =o[l] g :=
by { unfold is_o, exact forall‚ÇÇ_congr (Œª _ _, is_O_with_neg_left) }

alias is_o_neg_left ‚Üî is_o.of_neg_right is_o.neg_left

/-! ### Product of functions (right) -/

lemma is_O_with_fst_prod : is_O_with 1 l f' (Œª x, (f' x, g' x)) :=
is_O_with_of_le l $ Œª x, le_max_left _ _

lemma is_O_with_snd_prod : is_O_with 1 l g' (Œª x, (f' x, g' x)) :=
is_O_with_of_le l $ Œª x, le_max_right _ _

lemma is_O_fst_prod : f' =O[l] (Œª x, (f' x, g' x)) := is_O_with_fst_prod.is_O

lemma is_O_snd_prod : g' =O[l] (Œª x, (f' x, g' x)) := is_O_with_snd_prod.is_O

lemma is_O_fst_prod' {f' : Œ± ‚Üí E' √ó F'} : (Œª x, (f' x).1) =O[l] f' :=
by simpa [is_O, is_O_with] using is_O_fst_prod

lemma is_O_snd_prod' {f' : Œ± ‚Üí E' √ó F'} : (Œª x, (f' x).2) =O[l] f' :=
by simpa [is_O, is_O_with] using is_O_snd_prod

section

variables (f' k')

lemma is_O_with.prod_rightl (h : is_O_with c l f g') (hc : 0 ‚â§ c) :
  is_O_with c l f (Œª x, (g' x, k' x)) :=
(h.trans is_O_with_fst_prod hc).congr_const (mul_one c)

lemma is_O.prod_rightl (h : f =O[l] g') : f =O[l] (Œª x, (g' x, k' x)) :=
let ‚ü®c, cnonneg, hc‚ü© := h.exists_nonneg in (hc.prod_rightl k' cnonneg).is_O

lemma is_o.prod_rightl (h : f =o[l] g') : f =o[l] (Œª x, (g' x, k' x)) :=
is_o.of_is_O_with $ Œª c cpos, (h.forall_is_O_with cpos).prod_rightl k' cpos.le

lemma is_O_with.prod_rightr (h : is_O_with c l f g') (hc : 0 ‚â§ c) :
  is_O_with c l f (Œª x, (f' x, g' x)) :=
(h.trans is_O_with_snd_prod hc).congr_const (mul_one c)

lemma is_O.prod_rightr (h : f =O[l] g') : f =O[l] (Œª x, (f' x, g' x)) :=
let ‚ü®c, cnonneg, hc‚ü© := h.exists_nonneg in (hc.prod_rightr f' cnonneg).is_O

lemma is_o.prod_rightr (h : f =o[l] g') : f =o[l] (Œªx, (f' x, g' x)) :=
is_o.of_is_O_with $ Œª c cpos, (h.forall_is_O_with cpos).prod_rightr f' cpos.le

end

lemma is_O_with.prod_left_same (hf : is_O_with c l f' k') (hg : is_O_with c l g' k') :
  is_O_with c l (Œª x, (f' x, g' x)) k' :=
by rw is_O_with_iff at *; filter_upwards [hf, hg] with x using max_le

lemma is_O_with.prod_left (hf : is_O_with c l f' k') (hg : is_O_with c' l g' k') :
  is_O_with (max c c') l (Œª x, (f' x, g' x)) k' :=
(hf.weaken $ le_max_left c c').prod_left_same (hg.weaken $ le_max_right c c')

lemma is_O_with.prod_left_fst (h : is_O_with c l (Œª x, (f' x, g' x)) k') :
  is_O_with c l f' k' :=
(is_O_with_fst_prod.trans h zero_le_one).congr_const $ one_mul c

lemma is_O_with.prod_left_snd (h : is_O_with c l (Œª x, (f' x, g' x)) k') :
  is_O_with c l g' k' :=
(is_O_with_snd_prod.trans h zero_le_one).congr_const $ one_mul c

lemma is_O_with_prod_left :
   is_O_with c l (Œª x, (f' x, g' x)) k' ‚Üî is_O_with c l f' k' ‚àß is_O_with c l g' k' :=
‚ü®Œª h, ‚ü®h.prod_left_fst, h.prod_left_snd‚ü©, Œª h, h.1.prod_left_same h.2‚ü©

lemma is_O.prod_left (hf : f' =O[l] k') (hg : g' =O[l] k') : (Œª x, (f' x, g' x)) =O[l] k' :=
let ‚ü®c, hf‚ü© := hf.is_O_with, ‚ü®c', hg‚ü© := hg.is_O_with in (hf.prod_left hg).is_O

lemma is_O.prod_left_fst : (Œª x, (f' x, g' x)) =O[l] k' ‚Üí f' =O[l] k' := is_O.trans is_O_fst_prod
lemma is_O.prod_left_snd : (Œª x, (f' x, g' x)) =O[l] k' ‚Üí g' =O[l] k' := is_O.trans is_O_snd_prod

@[simp] lemma is_O_prod_left : (Œª x, (f' x, g' x)) =O[l] k' ‚Üî f' =O[l] k' ‚àß g' =O[l] k' :=
‚ü®Œª h, ‚ü®h.prod_left_fst, h.prod_left_snd‚ü©, Œª h, h.1.prod_left h.2‚ü©

lemma is_o.prod_left (hf : f' =o[l] k') (hg : g' =o[l] k') : (Œª x, (f' x, g' x)) =o[l] k' :=
is_o.of_is_O_with $ Œª c hc, (hf.forall_is_O_with hc).prod_left_same (hg.forall_is_O_with hc)

lemma is_o.prod_left_fst : (Œª x, (f' x, g' x)) =o[l] k' ‚Üí f' =o[l] k' :=
is_O.trans_is_o is_O_fst_prod

lemma is_o.prod_left_snd : (Œª x, (f' x, g' x)) =o[l] k' ‚Üí g' =o[l] k' :=
is_O.trans_is_o is_O_snd_prod

@[simp] lemma is_o_prod_left : (Œª x, (f' x, g' x)) =o[l] k' ‚Üî f' =o[l] k' ‚àß g' =o[l] k' :=
‚ü®Œª h, ‚ü®h.prod_left_fst, h.prod_left_snd‚ü©, Œª h, h.1.prod_left h.2‚ü©

lemma is_O_with.eq_zero_imp (h : is_O_with c l f'' g'') : ‚àÄ·∂† x in l, g'' x = 0 ‚Üí f'' x = 0 :=
eventually.mono h.bound $ Œª x hx hg, norm_le_zero_iff.1 $ by simpa [hg] using hx

lemma is_O.eq_zero_imp (h : f'' =O[l] g'') : ‚àÄ·∂† x in l, g'' x = 0 ‚Üí f'' x = 0 :=
let ‚ü®C, hC‚ü© := h.is_O_with in hC.eq_zero_imp

/-! ### Addition and subtraction -/

section add_sub

variables {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E'} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí F'}

theorem is_O_with.add (h‚ÇÅ : is_O_with c‚ÇÅ l f‚ÇÅ g) (h‚ÇÇ : is_O_with c‚ÇÇ l f‚ÇÇ g) :
  is_O_with (c‚ÇÅ + c‚ÇÇ) l (Œª x, f‚ÇÅ x + f‚ÇÇ x) g :=
by rw is_O_with at *; filter_upwards [h‚ÇÅ, h‚ÇÇ] with x hx‚ÇÅ hx‚ÇÇ using
calc ‚Äñf‚ÇÅ x + f‚ÇÇ x‚Äñ ‚â§ c‚ÇÅ * ‚Äñg x‚Äñ + c‚ÇÇ * ‚Äñg x‚Äñ : norm_add_le_of_le hx‚ÇÅ hx‚ÇÇ
               ... = (c‚ÇÅ + c‚ÇÇ) * ‚Äñg x‚Äñ       : (add_mul _ _ _).symm

theorem is_O.add (h‚ÇÅ : f‚ÇÅ =O[l] g) (h‚ÇÇ : f‚ÇÇ =O[l] g) : (Œª x, f‚ÇÅ x + f‚ÇÇ x) =O[l] g :=
let ‚ü®c‚ÇÅ, hc‚ÇÅ‚ü© := h‚ÇÅ.is_O_with, ‚ü®c‚ÇÇ, hc‚ÇÇ‚ü© := h‚ÇÇ.is_O_with in (hc‚ÇÅ.add hc‚ÇÇ).is_O

theorem is_o.add (h‚ÇÅ : f‚ÇÅ =o[l] g) (h‚ÇÇ : f‚ÇÇ =o[l] g) : (Œª x, f‚ÇÅ x + f‚ÇÇ x) =o[l] g :=
is_o.of_is_O_with $ Œª c cpos, ((h‚ÇÅ.forall_is_O_with $ half_pos cpos).add
  (h‚ÇÇ.forall_is_O_with $ half_pos cpos)).congr_const (add_halves c)

theorem is_o.add_add (h‚ÇÅ : f‚ÇÅ =o[l] g‚ÇÅ) (h‚ÇÇ : f‚ÇÇ =o[l] g‚ÇÇ) :
  (Œª x, f‚ÇÅ x + f‚ÇÇ x) =o[l] (Œª x, ‚Äñg‚ÇÅ x‚Äñ + ‚Äñg‚ÇÇ x‚Äñ) :=
by refine (h‚ÇÅ.trans_le $ Œª x, _).add (h‚ÇÇ.trans_le _);
  simp [abs_of_nonneg, add_nonneg]

theorem is_O.add_is_o (h‚ÇÅ : f‚ÇÅ =O[l] g) (h‚ÇÇ : f‚ÇÇ =o[l] g) : (Œª x, f‚ÇÅ x + f‚ÇÇ x) =O[l] g :=
h‚ÇÅ.add h‚ÇÇ.is_O

theorem is_o.add_is_O (h‚ÇÅ : f‚ÇÅ =o[l] g) (h‚ÇÇ : f‚ÇÇ =O[l] g) : (Œª x, f‚ÇÅ x + f‚ÇÇ x) =O[l] g :=
h‚ÇÅ.is_O.add h‚ÇÇ

theorem is_O_with.add_is_o (h‚ÇÅ : is_O_with c‚ÇÅ l f‚ÇÅ g) (h‚ÇÇ : f‚ÇÇ =o[l] g) (hc : c‚ÇÅ < c‚ÇÇ) :
  is_O_with c‚ÇÇ l (Œªx, f‚ÇÅ x + f‚ÇÇ x) g :=
(h‚ÇÅ.add (h‚ÇÇ.forall_is_O_with (sub_pos.2 hc))).congr_const (add_sub_cancel'_right _ _)

theorem is_o.add_is_O_with (h‚ÇÅ : f‚ÇÅ =o[l] g) (h‚ÇÇ : is_O_with c‚ÇÅ l f‚ÇÇ g) (hc : c‚ÇÅ < c‚ÇÇ) :
  is_O_with c‚ÇÇ l (Œªx, f‚ÇÅ x + f‚ÇÇ x) g :=
(h‚ÇÇ.add_is_o h‚ÇÅ hc).congr_left $ Œª _, add_comm _ _

theorem is_O_with.sub (h‚ÇÅ : is_O_with c‚ÇÅ l f‚ÇÅ g) (h‚ÇÇ : is_O_with c‚ÇÇ l f‚ÇÇ g) :
  is_O_with (c‚ÇÅ + c‚ÇÇ) l (Œª x, f‚ÇÅ x - f‚ÇÇ x) g :=
by simpa only [sub_eq_add_neg] using h‚ÇÅ.add h‚ÇÇ.neg_left

theorem is_O_with.sub_is_o (h‚ÇÅ : is_O_with c‚ÇÅ l f‚ÇÅ g) (h‚ÇÇ : f‚ÇÇ =o[l] g) (hc : c‚ÇÅ < c‚ÇÇ) :
  is_O_with c‚ÇÇ l (Œª x, f‚ÇÅ x - f‚ÇÇ x) g :=
by simpa only [sub_eq_add_neg] using h‚ÇÅ.add_is_o h‚ÇÇ.neg_left hc

theorem is_O.sub (h‚ÇÅ : f‚ÇÅ =O[l] g) (h‚ÇÇ : f‚ÇÇ =O[l] g) : (Œª x, f‚ÇÅ x - f‚ÇÇ x) =O[l] g :=
by simpa only [sub_eq_add_neg] using h‚ÇÅ.add h‚ÇÇ.neg_left

theorem is_o.sub (h‚ÇÅ : f‚ÇÅ =o[l] g) (h‚ÇÇ : f‚ÇÇ =o[l] g) : (Œª x, f‚ÇÅ x - f‚ÇÇ x) =o[l] g :=
by simpa only [sub_eq_add_neg] using h‚ÇÅ.add h‚ÇÇ.neg_left

end add_sub

/-! ### Lemmas about `is_O (f‚ÇÅ - f‚ÇÇ) g l` / `is_o (f‚ÇÅ - f‚ÇÇ) g l` treated as a binary relation -/

section is_oO_as_rel

variables {f‚ÇÅ f‚ÇÇ f‚ÇÉ : Œ± ‚Üí E'}

theorem is_O_with.symm (h : is_O_with c l (Œª x, f‚ÇÅ x - f‚ÇÇ x) g) :
  is_O_with c l (Œª x, f‚ÇÇ x - f‚ÇÅ x) g :=
h.neg_left.congr_left $ Œª x, neg_sub _ _

theorem is_O_with_comm :
  is_O_with c l (Œª x, f‚ÇÅ x - f‚ÇÇ x) g ‚Üî is_O_with c l (Œª x, f‚ÇÇ x - f‚ÇÅ x) g :=
‚ü®is_O_with.symm, is_O_with.symm‚ü©

theorem is_O.symm (h : (Œª x, f‚ÇÅ x - f‚ÇÇ x) =O[l] g) : (Œª x, f‚ÇÇ x - f‚ÇÅ x) =O[l] g :=
h.neg_left.congr_left $ Œª x, neg_sub _ _

theorem is_O_comm : (Œª x, f‚ÇÅ x - f‚ÇÇ x) =O[l] g ‚Üî (Œª x, f‚ÇÇ x - f‚ÇÅ x) =O[l] g :=
‚ü®is_O.symm, is_O.symm‚ü©

theorem is_o.symm (h : (Œª x, f‚ÇÅ x - f‚ÇÇ x) =o[l] g) : (Œª x, f‚ÇÇ x - f‚ÇÅ x) =o[l] g :=
by simpa only [neg_sub] using h.neg_left

theorem is_o_comm : (Œª x, f‚ÇÅ x - f‚ÇÇ x) =o[l] g ‚Üî (Œª x, f‚ÇÇ x - f‚ÇÅ x) =o[l] g :=
‚ü®is_o.symm, is_o.symm‚ü©

theorem is_O_with.triangle (h‚ÇÅ : is_O_with c l (Œª x, f‚ÇÅ x - f‚ÇÇ x) g)
  (h‚ÇÇ : is_O_with c' l (Œª x, f‚ÇÇ x - f‚ÇÉ x) g) :
  is_O_with (c + c') l (Œª x, f‚ÇÅ x - f‚ÇÉ x) g :=
(h‚ÇÅ.add h‚ÇÇ).congr_left $ Œª x, sub_add_sub_cancel _ _ _

theorem is_O.triangle (h‚ÇÅ : (Œª x, f‚ÇÅ x - f‚ÇÇ x) =O[l] g) (h‚ÇÇ : (Œª x, f‚ÇÇ x - f‚ÇÉ x) =O[l] g) :
  (Œª x, f‚ÇÅ x - f‚ÇÉ x) =O[l] g :=
(h‚ÇÅ.add h‚ÇÇ).congr_left $ Œª x, sub_add_sub_cancel _ _ _

theorem is_o.triangle (h‚ÇÅ : (Œª x, f‚ÇÅ x - f‚ÇÇ x) =o[l] g) (h‚ÇÇ : (Œª x, f‚ÇÇ x - f‚ÇÉ x) =o[l] g) :
  (Œª x, f‚ÇÅ x - f‚ÇÉ x) =o[l] g :=
(h‚ÇÅ.add h‚ÇÇ).congr_left $ Œª x, sub_add_sub_cancel _ _ _

theorem is_O.congr_of_sub (h : (Œª x, f‚ÇÅ x - f‚ÇÇ x) =O[l] g) : f‚ÇÅ =O[l] g ‚Üî f‚ÇÇ =O[l] g :=
‚ü®Œª h', (h'.sub h).congr_left (Œª x, sub_sub_cancel _ _),
 Œª h', (h.add h').congr_left (Œª x, sub_add_cancel _ _)‚ü©

theorem is_o.congr_of_sub (h : (Œª x, f‚ÇÅ x - f‚ÇÇ x) =o[l] g) : f‚ÇÅ =o[l] g ‚Üî f‚ÇÇ =o[l] g :=
‚ü®Œª h', (h'.sub h).congr_left (Œª x, sub_sub_cancel _ _),
 Œª h', (h.add h').congr_left (Œª x, sub_add_cancel _ _)‚ü©

end is_oO_as_rel

/-! ### Zero, one, and other constants -/

section zero_const

variables (g g' l)

theorem is_o_zero : (Œª x, (0 : E')) =o[l] g' :=
is_o.of_bound $ Œª c hc, univ_mem' $ Œª x,
by simpa using mul_nonneg hc.le (norm_nonneg $ g' x)

theorem is_O_with_zero (hc : 0 ‚â§ c) : is_O_with c l (Œª x, (0 : E')) g' :=
is_O_with.of_bound $ univ_mem' $ Œª x, by simpa using mul_nonneg hc (norm_nonneg $ g' x)

theorem is_O_with_zero' : is_O_with 0 l (Œª x, (0 : E')) g :=
is_O_with.of_bound $ univ_mem' $ Œª x, by simp

theorem is_O_zero : (Œª x, (0 : E')) =O[l] g :=
is_O_iff_is_O_with.2 ‚ü®0, is_O_with_zero' _ _‚ü©

theorem is_O_refl_left : (Œª x, f' x - f' x) =O[l] g' :=
(is_O_zero g' l).congr_left $ Œª x, (sub_self _).symm

theorem is_o_refl_left : (Œª x, f' x - f' x) =o[l] g' :=
(is_o_zero g' l).congr_left $ Œª x, (sub_self _).symm

variables {g g' l}

@[simp] theorem is_O_with_zero_right_iff :
  is_O_with c l f'' (Œª x, (0 : F')) ‚Üî f'' =·∂†[l] 0 :=
by simp only [is_O_with, exists_prop, true_and, norm_zero, mul_zero, norm_le_zero_iff,
  eventually_eq, pi.zero_apply]

@[simp] theorem is_O_zero_right_iff : f'' =O[l] (Œª x, (0 : F')) ‚Üî f'' =·∂†[l] 0 :=
‚ü®Œª h, let ‚ü®c, hc‚ü© := h.is_O_with in is_O_with_zero_right_iff.1 hc,
  Œª h, (is_O_with_zero_right_iff.2 h : is_O_with 1 _ _ _).is_O‚ü©

@[simp] theorem is_o_zero_right_iff :
  f'' =o[l] (Œª x, (0 : F')) ‚Üî f'' =·∂†[l] 0 :=
‚ü®Œª h, is_O_zero_right_iff.1 h.is_O, Œª h, is_o.of_is_O_with $ Œª c hc, is_O_with_zero_right_iff.2 h‚ü©

theorem is_O_with_const_const (c : E) {c' : F''} (hc' : c' ‚â† 0) (l : filter Œ±) :
  is_O_with (‚Äñc‚Äñ / ‚Äñc'‚Äñ) l (Œª x : Œ±, c) (Œª x, c') :=
begin
  unfold is_O_with,
  apply univ_mem',
  intro x,
  rw [mem_set_of_eq, div_mul_cancel],
  rwa [ne.def, norm_eq_zero]
end

theorem is_O_const_const (c : E) {c' : F''} (hc' : c' ‚â† 0) (l : filter Œ±) :
  (Œª x : Œ±, c) =O[l] (Œª x, c') :=
(is_O_with_const_const c hc' l).is_O

@[simp] theorem is_O_const_const_iff {c : E''} {c' : F''} (l : filter Œ±) [l.ne_bot] :
  (Œª x : Œ±, c) =O[l] (Œª x, c') ‚Üî (c' = 0 ‚Üí c = 0) :=
begin
  rcases eq_or_ne c' 0 with rfl|hc',
  { simp [eventually_eq] },
  { simp [hc', is_O_const_const _ hc'] }
end

@[simp] lemma is_O_pure {x} : f'' =O[pure x] g'' ‚Üî (g'' x = 0 ‚Üí f'' x = 0) :=
calc f'' =O[pure x] g'' ‚Üî (Œª y : Œ±, f'' x) =O[pure x] (Œª _, g'' x) : is_O_congr rfl rfl
                    ... ‚Üî g'' x = 0 ‚Üí f'' x = 0                    : is_O_const_const_iff _

end zero_const

@[simp] lemma is_O_with_top : is_O_with c ‚ä§ f g ‚Üî ‚àÄ x, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ := by rw is_O_with; refl

@[simp] lemma is_O_top : f =O[‚ä§] g ‚Üî ‚àÉ C, ‚àÄ x, ‚Äñf x‚Äñ ‚â§ C * ‚Äñg x‚Äñ := by rw is_O_iff; refl

@[simp] lemma is_o_top : f'' =o[‚ä§] g'' ‚Üî ‚àÄ x, f'' x = 0 :=
begin
  refine ‚ü®_, Œª h, (is_o_zero g'' ‚ä§).congr (Œª x, (h x).symm) (Œª x, rfl)‚ü©,
  simp only [is_o_iff, eventually_top],
  refine Œª h x, norm_le_zero_iff.1 _,
  have : tendsto (Œª c : ‚Ñù, c * ‚Äñg'' x‚Äñ) (ùìù[>] 0) (ùìù 0) :=
    ((continuous_id.mul continuous_const).tendsto' _ _ (zero_mul _)).mono_left inf_le_left,
  exact le_of_tendsto_of_tendsto tendsto_const_nhds this
    (eventually_nhds_within_iff.2 $ eventually_of_forall $ Œª c hc, h hc x)
end

@[simp] lemma is_O_with_principal {s : set Œ±} :
  is_O_with c (ùìü s) f g ‚Üî ‚àÄ x ‚àà s, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ :=
by rw is_O_with; refl

lemma is_O_principal {s : set Œ±} : f =O[ùìü s] g ‚Üî ‚àÉ c, ‚àÄ x ‚àà s, ‚Äñf x‚Äñ ‚â§ c * ‚Äñg x‚Äñ :=
by rw is_O_iff; refl

section

variables (F) [has_one F] [norm_one_class F]

theorem is_O_with_const_one (c : E) (l : filter Œ±) : is_O_with ‚Äñc‚Äñ l (Œª x : Œ±, c) (Œª x, (1 : F)) :=
by simp [is_O_with_iff]

theorem is_O_const_one (c : E) (l : filter Œ±) : (Œª x : Œ±, c) =O[l] (Œª x, (1 : F)) :=
(is_O_with_const_one F c l).is_O

theorem is_o_const_iff_is_o_one {c : F''} (hc : c ‚â† 0) :
  f =o[l] (Œª x, c) ‚Üî f =o[l] (Œª x, (1 : F)) :=
‚ü®Œª h, h.trans_is_O_with (is_O_with_const_one _ _ _) (norm_pos_iff.2 hc),
  Œª h, h.trans_is_O $ is_O_const_const _ hc _‚ü©

@[simp] theorem is_o_one_iff : f' =o[l] (Œª x, 1 : Œ± ‚Üí F) ‚Üî tendsto f' l (ùìù 0) :=
by simp only [is_o_iff, norm_one, mul_one, metric.nhds_basis_closed_ball.tendsto_right_iff,
  metric.mem_closed_ball, dist_zero_right]

@[simp] theorem is_O_one_iff : f =O[l] (Œª x, 1 : Œ± ‚Üí F) ‚Üî is_bounded_under (‚â§) l (Œª x, ‚Äñf x‚Äñ) :=
by { simp only [is_O_iff, norm_one, mul_one], refl }

alias is_O_one_iff ‚Üî _ _root_.filter.is_bounded_under.is_O_one

@[simp] theorem is_o_one_left_iff : (Œª x, 1 : Œ± ‚Üí F) =o[l] f ‚Üî tendsto (Œª x, ‚Äñf x‚Äñ) l at_top :=
calc (Œª x, 1 : Œ± ‚Üí F) =o[l] f ‚Üî ‚àÄ n : ‚Ñï, ‚àÄ·∂† x in l, ‚Üën * ‚Äñ(1 : F)‚Äñ ‚â§ ‚Äñf x‚Äñ :
  is_o_iff_nat_mul_le_aux $ or.inl $ Œª x, by simp only [norm_one, zero_le_one]
... ‚Üî ‚àÄ n : ‚Ñï, true ‚Üí ‚àÄ·∂† x in l, ‚Äñf x‚Äñ ‚àà Ici (n : ‚Ñù) :
  by simp only [norm_one, mul_one, true_implies_iff, mem_Ici]
... ‚Üî tendsto (Œª x, ‚Äñf x‚Äñ) l at_top : at_top_countable_basis_of_archimedean.1.tendsto_right_iff.symm

theorem _root_.filter.tendsto.is_O_one {c : E'} (h : tendsto f' l (ùìù c)) :
  f' =O[l] (Œª x, 1 : Œ± ‚Üí F) :=
h.norm.is_bounded_under_le.is_O_one F

theorem is_O.trans_tendsto_nhds (hfg : f =O[l] g') {y : F'} (hg : tendsto g' l (ùìù y)) :
  f =O[l] (Œª x, 1 : Œ± ‚Üí F) :=
hfg.trans $ hg.is_O_one F

end

theorem is_o_const_iff {c : F''} (hc : c ‚â† 0) :
  f'' =o[l] (Œª x, c) ‚Üî tendsto f'' l (ùìù 0) :=
(is_o_const_iff_is_o_one ‚Ñù hc).trans (is_o_one_iff _)

lemma is_o_id_const {c : F''} (hc : c ‚â† 0) :
  (Œª (x : E''), x) =o[ùìù 0] (Œª x, c) :=
(is_o_const_iff hc).mpr (continuous_id.tendsto 0)

theorem _root_.filter.is_bounded_under.is_O_const (h : is_bounded_under (‚â§) l (norm ‚àò f))
  {c : F''} (hc : c ‚â† 0) : f =O[l] (Œª x, c) :=
(h.is_O_one ‚Ñù).trans (is_O_const_const _ hc _)

theorem is_O_const_of_tendsto {y : E''} (h : tendsto f'' l (ùìù y)) {c : F''} (hc : c ‚â† 0) :
  f'' =O[l] (Œª x, c) :=
h.norm.is_bounded_under_le.is_O_const hc

lemma is_O.is_bounded_under_le {c : F} (h : f =O[l] (Œª x, c)) :
  is_bounded_under (‚â§) l (norm ‚àò f) :=
let ‚ü®c', hc'‚ü© := h.bound in ‚ü®c' * ‚Äñc‚Äñ, eventually_map.2 hc'‚ü©

theorem is_O_const_of_ne {c : F''} (hc : c ‚â† 0) :
  f =O[l] (Œª x, c) ‚Üî is_bounded_under (‚â§) l (norm ‚àò f) :=
‚ü®Œª h, h.is_bounded_under_le, Œª h, h.is_O_const hc‚ü©

theorem is_O_const_iff {c : F''} :
  f'' =O[l] (Œª x, c) ‚Üî (c = 0 ‚Üí f'' =·∂†[l] 0) ‚àß is_bounded_under (‚â§) l (Œª x, ‚Äñf'' x‚Äñ) :=
begin
  refine ‚ü®Œª h, ‚ü®Œª hc, is_O_zero_right_iff.1 (by rwa ‚Üê hc), h.is_bounded_under_le‚ü©, _‚ü©,
  rintro ‚ü®hcf, hf‚ü©,
  rcases eq_or_ne c 0 with hc|hc,
  exacts [(hcf hc).trans_is_O (is_O_zero _ _), hf.is_O_const hc]
end

theorem is_O_iff_is_bounded_under_le_div (h : ‚àÄ·∂† x in l, g'' x ‚â† 0) :
  f =O[l] g'' ‚Üî is_bounded_under (‚â§) l (Œª x, ‚Äñf x‚Äñ / ‚Äñg'' x‚Äñ) :=
begin
  simp only [is_O_iff, is_bounded_under, is_bounded, eventually_map],
  exact exists_congr (Œª c, eventually_congr $ h.mono $
    Œª x hx, (div_le_iff $ norm_pos_iff.2 hx).symm)
end

/-- `(Œª x, c) =O[l] f` if and only if `f` is bounded away from zero. -/
lemma is_O_const_left_iff_pos_le_norm {c : E''} (hc : c ‚â† 0) :
  (Œª x, c) =O[l] f' ‚Üî ‚àÉ b, 0 < b ‚àß ‚àÄ·∂† x in l, b ‚â§ ‚Äñf' x‚Äñ :=
begin
  split,
  { intro h,
    rcases h.exists_pos with ‚ü®C, hC‚ÇÄ, hC‚ü©,
    refine ‚ü®‚Äñc‚Äñ / C, div_pos (norm_pos_iff.2 hc) hC‚ÇÄ, _‚ü©,
    exact hC.bound.mono (Œª x, (div_le_iff' hC‚ÇÄ).2) },
  { rintro ‚ü®b, hb‚ÇÄ, hb‚ü©,
    refine is_O.of_bound (‚Äñc‚Äñ / b) (hb.mono $ Œª x hx, _),
    rw [div_mul_eq_mul_div, mul_div_assoc],
    exact le_mul_of_one_le_right (norm_nonneg _) ((one_le_div hb‚ÇÄ).2 hx) }
end

section

variable (ùïú)

end

theorem is_O.trans_tendsto (hfg : f'' =O[l] g'') (hg : tendsto g'' l (ùìù 0)) :
  tendsto f'' l (ùìù 0) :=
(is_o_one_iff ‚Ñù).1 $ hfg.trans_is_o $ (is_o_one_iff ‚Ñù).2 hg

theorem is_o.trans_tendsto (hfg : f'' =o[l] g'') (hg : tendsto g'' l (ùìù 0)) :
  tendsto f'' l (ùìù 0) :=
hfg.is_O.trans_tendsto hg

/-! ### Multiplication by a constant -/

theorem is_O_with_const_mul_self (c : R) (f : Œ± ‚Üí R) (l : filter Œ±) :
  is_O_with ‚Äñc‚Äñ l (Œª x, c * f x) f :=
is_O_with_of_le' _ $ Œª x, norm_mul_le _ _

theorem is_O_const_mul_self (c : R) (f : Œ± ‚Üí R) (l : filter Œ±) : (Œª x, c * f x) =O[l] f :=
(is_O_with_const_mul_self c f l).is_O

theorem is_O_with.const_mul_left {f : Œ± ‚Üí R} (h : is_O_with c l f g) (c' : R) :
  is_O_with (‚Äñc'‚Äñ * c) l (Œª x, c' * f x) g :=
(is_O_with_const_mul_self c' f l).trans h (norm_nonneg c')

theorem is_O.const_mul_left {f : Œ± ‚Üí R} (h : f =O[l] g) (c' : R) :
  (Œª x, c' * f x) =O[l] g :=
let ‚ü®c, hc‚ü© := h.is_O_with in (hc.const_mul_left c').is_O

theorem is_O_with_self_const_mul' (u : RÀ£) (f : Œ± ‚Üí R) (l : filter Œ±) :
  is_O_with ‚Äñ(‚Üëu‚Åª¬π:R)‚Äñ l f (Œª x, ‚Üëu * f x) :=
(is_O_with_const_mul_self ‚Üëu‚Åª¬π _ l).congr_left $ Œª x, u.inv_mul_cancel_left (f x)

theorem is_O_with_self_const_mul (c : ùïú) (hc : c ‚â† 0) (f : Œ± ‚Üí ùïú) (l : filter Œ±) :
  is_O_with ‚Äñc‚Äñ‚Åª¬π l f (Œª x, c * f x) :=
(is_O_with_self_const_mul' (units.mk0 c hc) f l).congr_const $
  norm_inv c

theorem is_O_self_const_mul' {c : R} (hc : is_unit c) (f : Œ± ‚Üí R) (l : filter Œ±) :
  f =O[l] (Œª x, c * f x) :=
let ‚ü®u, hu‚ü© := hc in hu ‚ñ∏ (is_O_with_self_const_mul' u f l).is_O

theorem is_O_self_const_mul (c : ùïú) (hc : c ‚â† 0) (f : Œ± ‚Üí ùïú) (l : filter Œ±) :
  f =O[l] (Œª x, c * f x) :=
is_O_self_const_mul' (is_unit.mk0 c hc) f l

theorem is_O_const_mul_left_iff' {f : Œ± ‚Üí R} {c : R} (hc : is_unit c) :
  (Œª x, c * f x) =O[l] g ‚Üî f =O[l] g :=
‚ü®(is_O_self_const_mul' hc f l).trans, Œª h, h.const_mul_left c‚ü©

theorem is_O_const_mul_left_iff {f : Œ± ‚Üí ùïú} {c : ùïú} (hc : c ‚â† 0) :
  (Œª x, c * f x) =O[l] g ‚Üî f =O[l] g :=
is_O_const_mul_left_iff' $ is_unit.mk0 c hc

theorem is_o.const_mul_left {f : Œ± ‚Üí R} (h : f =o[l] g) (c : R) : (Œª x, c * f x) =o[l] g :=
(is_O_const_mul_self c f l).trans_is_o h

theorem is_o_const_mul_left_iff' {f : Œ± ‚Üí R} {c : R} (hc : is_unit c) :
  (Œª x, c * f x) =o[l] g ‚Üî f =o[l] g :=
‚ü®(is_O_self_const_mul' hc f l).trans_is_o, Œª h, h.const_mul_left c‚ü©

theorem is_o_const_mul_left_iff {f : Œ± ‚Üí ùïú} {c : ùïú} (hc : c ‚â† 0) :
  (Œª x, c * f x) =o[l] g ‚Üî f =o[l] g :=
is_o_const_mul_left_iff' $ is_unit.mk0 c hc

theorem is_O_with.of_const_mul_right {g : Œ± ‚Üí R} {c : R} (hc' : 0 ‚â§ c')
  (h : is_O_with c' l f (Œª x, c * g x)) :
  is_O_with (c' * ‚Äñc‚Äñ) l f g :=
h.trans (is_O_with_const_mul_self c g l) hc'

theorem is_O.of_const_mul_right {g : Œ± ‚Üí R} {c : R} (h : f =O[l] (Œª x, c * g x)) :
  f =O[l] g :=
let ‚ü®c, cnonneg, hc‚ü© := h.exists_nonneg in (hc.of_const_mul_right cnonneg).is_O

theorem is_O_with.const_mul_right' {g : Œ± ‚Üí R} {u : RÀ£} {c' : ‚Ñù} (hc' : 0 ‚â§ c')
  (h : is_O_with c' l f g) :
  is_O_with (c' * ‚Äñ(‚Üëu‚Åª¬π:R)‚Äñ) l f (Œª x, ‚Üëu * g x) :=
h.trans (is_O_with_self_const_mul' _ _ _) hc'

theorem is_O_with.const_mul_right {g : Œ± ‚Üí ùïú} {c : ùïú} (hc : c ‚â† 0)
  {c' : ‚Ñù} (hc' : 0 ‚â§ c') (h : is_O_with c' l f g) :
  is_O_with (c' * ‚Äñc‚Äñ‚Åª¬π) l f (Œª x, c * g x) :=
h.trans (is_O_with_self_const_mul c hc g l) hc'

theorem is_O.const_mul_right' {g : Œ± ‚Üí R} {c : R} (hc : is_unit c) (h : f =O[l] g) :
  f =O[l] (Œª x, c * g x) :=
h.trans (is_O_self_const_mul' hc g l)

theorem is_O.const_mul_right {g : Œ± ‚Üí ùïú} {c : ùïú} (hc : c ‚â† 0) (h : f =O[l] g) :
  f =O[l] (Œª x, c * g x) :=
h.const_mul_right' $ is_unit.mk0 c hc

theorem is_O_const_mul_right_iff' {g : Œ± ‚Üí R} {c : R} (hc : is_unit c) :
  f =O[l] (Œª x, c * g x) ‚Üî f =O[l] g :=
‚ü®Œª h, h.of_const_mul_right, Œª h, h.const_mul_right' hc‚ü©

theorem is_O_const_mul_right_iff {g : Œ± ‚Üí ùïú} {c : ùïú} (hc : c ‚â† 0) :
  f =O[l] (Œª x, c * g x) ‚Üî f =O[l] g :=
is_O_const_mul_right_iff' $ is_unit.mk0 c hc

theorem is_o.of_const_mul_right {g : Œ± ‚Üí R} {c : R} (h : f =o[l] (Œª x, c * g x)) :
  f =o[l] g :=
h.trans_is_O (is_O_const_mul_self c g l)

theorem is_o.const_mul_right' {g : Œ± ‚Üí R} {c : R} (hc : is_unit c) (h : f =o[l] g) :
  f =o[l] (Œª x, c * g x) :=
h.trans_is_O (is_O_self_const_mul' hc g l)

theorem is_o.const_mul_right {g : Œ± ‚Üí ùïú} {c : ùïú} (hc : c ‚â† 0) (h : f =o[l] g) :
  f =o[l] (Œª x, c * g x) :=
h.const_mul_right' $ is_unit.mk0 c hc

theorem is_o_const_mul_right_iff' {g : Œ± ‚Üí R} {c : R} (hc : is_unit c) :
  f =o[l] (Œª x, c * g x) ‚Üî f =o[l] g :=
‚ü®Œª h, h.of_const_mul_right, Œª h, h.const_mul_right' hc‚ü©

theorem is_o_const_mul_right_iff {g : Œ± ‚Üí ùïú} {c : ùïú} (hc : c ‚â† 0) :
  f =o[l] (Œª x, c * g x) ‚Üî f =o[l] g :=
is_o_const_mul_right_iff' $ is_unit.mk0 c hc

/-! ### Multiplication -/

theorem is_O_with.mul {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí R} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí ùïú} {c‚ÇÅ c‚ÇÇ : ‚Ñù}
  (h‚ÇÅ : is_O_with c‚ÇÅ l f‚ÇÅ g‚ÇÅ) (h‚ÇÇ : is_O_with c‚ÇÇ l f‚ÇÇ g‚ÇÇ) :
  is_O_with (c‚ÇÅ * c‚ÇÇ) l (Œª x, f‚ÇÅ x * f‚ÇÇ x) (Œª x, g‚ÇÅ x * g‚ÇÇ x) :=
begin
  unfold is_O_with at *,
  filter_upwards [h‚ÇÅ, h‚ÇÇ] with _ hx‚ÇÅ hx‚ÇÇ,
  apply le_trans (norm_mul_le _ _),
  convert mul_le_mul hx‚ÇÅ hx‚ÇÇ (norm_nonneg _) (le_trans (norm_nonneg _) hx‚ÇÅ) using 1,
  rw [norm_mul, mul_mul_mul_comm]
end

theorem is_O.mul {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí R} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí ùïú} (h‚ÇÅ : f‚ÇÅ =O[l] g‚ÇÅ) (h‚ÇÇ : f‚ÇÇ =O[l] g‚ÇÇ) :
  (Œª x, f‚ÇÅ x * f‚ÇÇ x) =O[l] (Œª x, g‚ÇÅ x * g‚ÇÇ x) :=
let ‚ü®c, hc‚ü© := h‚ÇÅ.is_O_with, ‚ü®c', hc'‚ü© := h‚ÇÇ.is_O_with in (hc.mul hc').is_O

theorem is_O.mul_is_o {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí R} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí ùïú}
  (h‚ÇÅ : f‚ÇÅ =O[l] g‚ÇÅ) (h‚ÇÇ : f‚ÇÇ =o[l] g‚ÇÇ) :
  (Œª x, f‚ÇÅ x * f‚ÇÇ x) =o[l] (Œª x, g‚ÇÅ x * g‚ÇÇ x) :=
begin
  unfold is_o at *,
  intros c cpos,
  rcases h‚ÇÅ.exists_pos with ‚ü®c', c'pos, hc'‚ü©,
  exact (hc'.mul (h‚ÇÇ (div_pos cpos c'pos))).congr_const (mul_div_cancel' _ (ne_of_gt c'pos))
end

theorem is_o.mul_is_O {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí R} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí ùïú} (h‚ÇÅ : f‚ÇÅ =o[l] g‚ÇÅ) (h‚ÇÇ : f‚ÇÇ =O[l] g‚ÇÇ) :
  (Œª x, f‚ÇÅ x * f‚ÇÇ x) =o[l] (Œª x, g‚ÇÅ x * g‚ÇÇ x) :=
begin
  unfold is_o at *,
  intros c cpos,
  rcases h‚ÇÇ.exists_pos with ‚ü®c', c'pos, hc'‚ü©,
  exact ((h‚ÇÅ (div_pos cpos c'pos)).mul hc').congr_const (div_mul_cancel _ (ne_of_gt c'pos))
end

theorem is_o.mul {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí R} {g‚ÇÅ g‚ÇÇ : Œ± ‚Üí ùïú} (h‚ÇÅ : f‚ÇÅ =o[l] g‚ÇÅ) (h‚ÇÇ : f‚ÇÇ =o[l] g‚ÇÇ) :
  (Œª x, f‚ÇÅ x * f‚ÇÇ x) =o[l] (Œª x, g‚ÇÅ x * g‚ÇÇ x) :=
h‚ÇÅ.mul_is_O h‚ÇÇ.is_O

theorem is_O_with.pow' {f : Œ± ‚Üí R} {g : Œ± ‚Üí ùïú} (h : is_O_with c l f g) :
  ‚àÄ n : ‚Ñï, is_O_with (nat.cases_on n ‚Äñ(1 : R)‚Äñ (Œª n, c ^ (n + 1))) l (Œª x, f x ^ n) (Œª x, g x ^ n)
| 0 := by simpa using is_O_with_const_const (1 : R) (one_ne_zero' ùïú) l
| 1 := by simpa
| (n + 2) := by simpa [pow_succ] using h.mul (is_O_with.pow' (n + 1))

theorem is_O_with.pow [norm_one_class R] {f : Œ± ‚Üí R} {g : Œ± ‚Üí ùïú} (h : is_O_with c l f g) :
  ‚àÄ n : ‚Ñï, is_O_with (c ^ n) l (Œª x, f x ^ n) (Œª x, g x ^ n)
| 0 := by simpa using h.pow' 0
| (n + 1) := h.pow' (n + 1)

theorem is_O_with.of_pow {n : ‚Ñï} {f : Œ± ‚Üí ùïú} {g : Œ± ‚Üí R} (h : is_O_with c l (f ^ n) (g ^ n))
  (hn : n ‚â† 0) (hc : c ‚â§ c' ^ n) (hc' : 0 ‚â§ c') : is_O_with c' l f g :=
is_O_with.of_bound $ (h.weaken hc).bound.mono $ Œª x hx,
  le_of_pow_le_pow n (mul_nonneg hc' $ norm_nonneg _) hn.bot_lt $
    calc ‚Äñf x‚Äñ ^ n = ‚Äñ(f x) ^ n‚Äñ : (norm_pow _ _).symm
               ... ‚â§ c' ^ n * ‚Äñ(g x) ^ n‚Äñ : hx
               ... ‚â§ c' ^ n * ‚Äñg x‚Äñ ^ n :
      mul_le_mul_of_nonneg_left (norm_pow_le' _ hn.bot_lt) (pow_nonneg hc' _)
               ... = (c' * ‚Äñg x‚Äñ) ^ n : (mul_pow _ _ _).symm

theorem is_O.pow {f : Œ± ‚Üí R} {g : Œ± ‚Üí ùïú} (h : f =O[l] g) (n : ‚Ñï) :
  (Œª x, f x ^ n) =O[l] (Œª x, g x ^ n) :=
let ‚ü®C, hC‚ü© := h.is_O_with in is_O_iff_is_O_with.2 ‚ü®_, hC.pow' n‚ü©

theorem is_O.of_pow {f : Œ± ‚Üí ùïú} {g : Œ± ‚Üí R} {n : ‚Ñï} (hn : n ‚â† 0) (h : (f ^ n) =O[l] (g ^ n)) :
  f =O[l] g :=
begin
  rcases h.exists_pos with ‚ü®C, hC‚ÇÄ, hC‚ü©,
  obtain ‚ü®c, hc‚ÇÄ, hc‚ü© : ‚àÉ c : ‚Ñù, 0 ‚â§ c ‚àß C ‚â§ c ^ n,
    from ((eventually_ge_at_top _).and $ (tendsto_pow_at_top hn).eventually_ge_at_top C).exists,
  exact (hC.of_pow hn hc hc‚ÇÄ).is_O
end

theorem is_o.pow {f : Œ± ‚Üí R} {g : Œ± ‚Üí ùïú} (h : f =o[l] g) {n : ‚Ñï} (hn : 0 < n) :
  (Œª x, f x ^ n) =o[l] (Œª x, g x ^ n) :=
begin
  cases n, exact hn.false.elim, clear hn,
  induction n with n ihn, { simpa only [pow_one] },
  convert h.mul ihn; simp [pow_succ]
end

theorem is_o.of_pow {f : Œ± ‚Üí ùïú} {g : Œ± ‚Üí R} {n : ‚Ñï} (h : (f ^ n) =o[l] (g ^ n)) (hn : n ‚â† 0) :
  f =o[l] g :=
is_o.of_is_O_with $ Œª c hc, (h.def' $ pow_pos hc _).of_pow hn le_rfl hc.le

/-! ### Inverse -/

theorem is_O_with.inv_rev {f : Œ± ‚Üí ùïú} {g : Œ± ‚Üí ùïú'} (h : is_O_with c l f g)
  (h‚ÇÄ : ‚àÄ·∂† x in l, f x = 0 ‚Üí g x = 0) : is_O_with c l (Œª x, (g x)‚Åª¬π) (Œª x, (f x)‚Åª¬π) :=
begin
  refine is_O_with.of_bound (h.bound.mp (h‚ÇÄ.mono $ Œª x h‚ÇÄ hle, _)),
  cases eq_or_ne (f x) 0 with hx hx,
  { simp only [hx, h‚ÇÄ hx, inv_zero, norm_zero, mul_zero] },
  { have hc : 0 < c, from pos_of_mul_pos_left ((norm_pos_iff.2 hx).trans_le hle) (norm_nonneg _),
    replace hle := inv_le_inv_of_le (norm_pos_iff.2 hx) hle,
    simpa only [norm_inv, mul_inv, ‚Üê div_eq_inv_mul, div_le_iff hc] using hle }
end

theorem is_O.inv_rev {f : Œ± ‚Üí ùïú} {g : Œ± ‚Üí ùïú'} (h : f =O[l] g)
  (h‚ÇÄ : ‚àÄ·∂† x in l, f x = 0 ‚Üí g x = 0) : (Œª x, (g x)‚Åª¬π) =O[l] (Œª x, (f x)‚Åª¬π) :=
let ‚ü®c, hc‚ü© := h.is_O_with in (hc.inv_rev h‚ÇÄ).is_O

theorem is_o.inv_rev {f : Œ± ‚Üí ùïú} {g : Œ± ‚Üí ùïú'} (h : f =o[l] g)
  (h‚ÇÄ : ‚àÄ·∂† x in l, f x = 0 ‚Üí g x = 0) : (Œª x, (g x)‚Åª¬π) =o[l] (Œª x, (f x)‚Åª¬π) :=
is_o.of_is_O_with $ Œª c hc, (h.def' hc).inv_rev h‚ÇÄ

/-! ### Scalar multiplication -/

section smul_const
variables [normed_space ùïú E']

theorem is_O_with.const_smul_left (h : is_O_with c l f' g) (c' : ùïú) :
  is_O_with (‚Äñc'‚Äñ * c) l (Œª x, c' ‚Ä¢ f' x) g :=
is_O_with.of_norm_left $
  by simpa only [‚Üê norm_smul, norm_norm] using h.norm_left.const_mul_left (‚Äñc'‚Äñ)

lemma is_O.const_smul_left (h : f' =O[l] g) (c : ùïú) : (c ‚Ä¢ f') =O[l] g :=
let ‚ü®b, hb‚ü© := h.is_O_with in (hb.const_smul_left _).is_O

lemma is_o.const_smul_left (h : f' =o[l] g) (c : ùïú) : (c ‚Ä¢ f') =o[l] g :=
is_o.of_norm_left $ by simpa only [‚Üê norm_smul] using h.norm_left.const_mul_left (‚Äñc‚Äñ)

theorem is_O_const_smul_left {c : ùïú} (hc : c ‚â† 0) :
  (Œª x, c ‚Ä¢ f' x) =O[l] g ‚Üî f' =O[l] g :=
begin
  have cne0 : ‚Äñc‚Äñ ‚â† 0, from mt norm_eq_zero.mp hc,
  rw [‚Üêis_O_norm_left], simp only [norm_smul],
  rw [is_O_const_mul_left_iff cne0, is_O_norm_left],
end

theorem is_o_const_smul_left {c : ùïú} (hc : c ‚â† 0) :
  (Œª x, c ‚Ä¢ f' x) =o[l] g ‚Üî f' =o[l] g :=
begin
  have cne0 : ‚Äñc‚Äñ ‚â† 0, from mt norm_eq_zero.mp hc,
  rw [‚Üêis_o_norm_left], simp only [norm_smul],
  rw [is_o_const_mul_left_iff cne0, is_o_norm_left]
end

theorem is_O_const_smul_right {c : ùïú} (hc : c ‚â† 0) :
  f =O[l] (Œª x, c ‚Ä¢ f' x) ‚Üî f =O[l] f' :=
begin
  have cne0 : ‚Äñc‚Äñ ‚â† 0, from mt norm_eq_zero.mp hc,
  rw [‚Üêis_O_norm_right], simp only [norm_smul],
  rw [is_O_const_mul_right_iff cne0, is_O_norm_right]
end

theorem is_o_const_smul_right {c : ùïú} (hc : c ‚â† 0) :
  f =o[l] (Œª x, c ‚Ä¢ f' x) ‚Üî f =o[l] f' :=
begin
  have cne0 : ‚Äñc‚Äñ ‚â† 0, from mt norm_eq_zero.mp hc,
  rw [‚Üêis_o_norm_right], simp only [norm_smul],
  rw [is_o_const_mul_right_iff cne0, is_o_norm_right]
end

end smul_const

section smul

variables [normed_space ùïú E'] [normed_space ùïú' F'] {k‚ÇÅ : Œ± ‚Üí ùïú} {k‚ÇÇ : Œ± ‚Üí ùïú'}

theorem is_O_with.smul (h‚ÇÅ : is_O_with c l k‚ÇÅ k‚ÇÇ) (h‚ÇÇ : is_O_with c' l f' g') :
  is_O_with (c * c') l (Œª x, k‚ÇÅ x ‚Ä¢ f' x) (Œª x, k‚ÇÇ x ‚Ä¢ g' x) :=
by refine ((h‚ÇÅ.norm_norm.mul h‚ÇÇ.norm_norm).congr rfl _ _).of_norm_norm;
  by intros; simp only [norm_smul]

theorem is_O.smul (h‚ÇÅ : k‚ÇÅ =O[l] k‚ÇÇ) (h‚ÇÇ : f' =O[l] g') :
  (Œª x, k‚ÇÅ x ‚Ä¢ f' x) =O[l] (Œª x, k‚ÇÇ x ‚Ä¢ g' x) :=
by refine ((h‚ÇÅ.norm_norm.mul h‚ÇÇ.norm_norm).congr _ _).of_norm_norm;
  by intros; simp only [norm_smul]

theorem is_O.smul_is_o (h‚ÇÅ : k‚ÇÅ =O[l] k‚ÇÇ) (h‚ÇÇ : f' =o[l] g') :
  (Œª x, k‚ÇÅ x ‚Ä¢ f' x) =o[l] (Œª x, k‚ÇÇ x ‚Ä¢ g' x) :=
by refine ((h‚ÇÅ.norm_norm.mul_is_o h‚ÇÇ.norm_norm).congr _ _).of_norm_norm;
  by intros; simp only [norm_smul]

theorem is_o.smul_is_O (h‚ÇÅ : k‚ÇÅ =o[l] k‚ÇÇ) (h‚ÇÇ : f' =O[l] g') :
  (Œª x, k‚ÇÅ x ‚Ä¢ f' x) =o[l] (Œª x, k‚ÇÇ x ‚Ä¢ g' x) :=
by refine ((h‚ÇÅ.norm_norm.mul_is_O h‚ÇÇ.norm_norm).congr _ _).of_norm_norm;
  by intros; simp only [norm_smul]

theorem is_o.smul (h‚ÇÅ : k‚ÇÅ =o[l] k‚ÇÇ) (h‚ÇÇ : f' =o[l] g') :
  (Œª x, k‚ÇÅ x ‚Ä¢ f' x) =o[l] (Œª x, k‚ÇÇ x ‚Ä¢ g' x) :=
by refine ((h‚ÇÅ.norm_norm.mul h‚ÇÇ.norm_norm).congr _ _).of_norm_norm;
  by intros; simp only [norm_smul]

end smul

/-! ### Sum -/

section sum

variables {Œπ : Type*} {A : Œπ ‚Üí Œ± ‚Üí E'} {C : Œπ ‚Üí ‚Ñù} {s : finset Œπ}

theorem is_O_with.sum (h : ‚àÄ i ‚àà s, is_O_with (C i) l (A i) g) :
  is_O_with (‚àë i in s, C i) l (Œª x, ‚àë i in s, A i x) g :=
begin
  induction s using finset.induction_on with i s is IH,
  { simp only [is_O_with_zero', finset.sum_empty, forall_true_iff] },
  { simp only [is, finset.sum_insert, not_false_iff],
    exact (h _ (finset.mem_insert_self i s)).add (IH (Œª j hj, h _ (finset.mem_insert_of_mem hj))) }
end

theorem is_O.sum (h : ‚àÄ i ‚àà s, A i =O[l] g) :
  (Œª x, ‚àë i in s, A i x) =O[l] g :=
begin
  unfold is_O at *,
  choose! C hC using h,
  exact ‚ü®_, is_O_with.sum hC‚ü©,
end

theorem is_o.sum (h : ‚àÄ i ‚àà s, (A i) =o[l] g') :
  (Œª x, ‚àë i in s, A i x) =o[l] g' :=
begin
  induction s using finset.induction_on with i s is IH,
  { simp only [is_o_zero, finset.sum_empty, forall_true_iff] },
  { simp only [is, finset.sum_insert, not_false_iff],
    exact (h _ (finset.mem_insert_self i s)).add (IH (Œª j hj, h _ (finset.mem_insert_of_mem hj))) }
end

end sum

/-! ### Relation between `f = o(g)` and `f / g ‚Üí 0` -/

theorem is_o.tendsto_div_nhds_zero {f g : Œ± ‚Üí ùïú} (h : f =o[l] g) :
  tendsto (Œª x, f x / (g x)) l (ùìù 0) :=
(is_o_one_iff ùïú).mp $
calc (Œª x, f x / g x) =o[l] (Œª x, g x / g x) :
  by simpa only [div_eq_mul_inv] using h.mul_is_O (is_O_refl _ _)
... =O[l] (Œª x, (1 : ùïú)) :
  is_O_of_le _ (Œª x, by simp [div_self_le_one])

theorem is_o.tendsto_inv_smul_nhds_zero [normed_space ùïú E'] {f : Œ± ‚Üí E'} {g : Œ± ‚Üí ùïú} {l : filter Œ±}
  (h : f =o[l] g) : tendsto (Œª x, (g x)‚Åª¬π ‚Ä¢ f x) l (ùìù 0) :=
by simpa only [div_eq_inv_mul, ‚Üê norm_inv, ‚Üê norm_smul,
  ‚Üê tendsto_zero_iff_norm_tendsto_zero] using h.norm_norm.tendsto_div_nhds_zero

theorem is_o_iff_tendsto' {f g : Œ± ‚Üí ùïú} (hgf : ‚àÄ·∂† x in l, g x = 0 ‚Üí f x = 0) :
  f =o[l] g ‚Üî tendsto (Œª x, f x / (g x)) l (ùìù 0) :=
‚ü®is_o.tendsto_div_nhds_zero, Œª h,
  (((is_o_one_iff _).mpr h).mul_is_O (is_O_refl g l)).congr'
    (hgf.mono $ Œª x, div_mul_cancel_of_imp) (eventually_of_forall $ Œª x, one_mul _)‚ü©

theorem is_o_iff_tendsto {f g : Œ± ‚Üí ùïú} (hgf : ‚àÄ x, g x = 0 ‚Üí f x = 0) :
  f =o[l] g ‚Üî tendsto (Œª x, f x / (g x)) l (ùìù 0) :=
is_o_iff_tendsto' (eventually_of_forall hgf)

alias is_o_iff_tendsto' ‚Üî _ is_o_of_tendsto'
alias is_o_iff_tendsto ‚Üî _ is_o_of_tendsto

lemma is_o_const_left_of_ne {c : E''} (hc : c ‚â† 0) :
  (Œª x, c) =o[l] g ‚Üî tendsto (Œª x, ‚Äñg x‚Äñ) l at_top :=
begin
  simp only [‚Üê is_o_one_left_iff ‚Ñù],
  exact ‚ü®(is_O_const_const (1 : ‚Ñù) hc l).trans_is_o, (is_O_const_one ‚Ñù c l).trans_is_o‚ü©
end

@[simp] lemma is_o_const_left {c : E''} :
  (Œª x, c) =o[l] g'' ‚Üî c = 0 ‚à® tendsto (norm ‚àò g'') l at_top :=
begin
  rcases eq_or_ne c 0 with rfl | hc,
  { simp only [is_o_zero, eq_self_iff_true, true_or] },
  { simp only [hc, false_or, is_o_const_left_of_ne hc] }
end

@[simp] theorem is_o_const_const_iff [ne_bot l] {d : E''} {c : F''} :
  (Œª x, d) =o[l] (Œª x, c) ‚Üî d = 0 :=
have ¬¨tendsto (function.const Œ± ‚Äñc‚Äñ) l at_top,
  from not_tendsto_at_top_of_tendsto_nhds tendsto_const_nhds,
by simp [function.const, this]

@[simp] lemma is_o_pure {x} : f'' =o[pure x] g'' ‚Üî f'' x = 0 :=
calc f'' =o[pure x] g'' ‚Üî (Œª y : Œ±, f'' x) =o[pure x] (Œª _, g'' x) : is_o_congr rfl rfl
                    ... ‚Üî f'' x = 0                                : is_o_const_const_iff

lemma is_o_const_id_comap_norm_at_top (c : F'') : (Œª x : E'', c) =o[comap norm at_top] id :=
is_o_const_left.2 $ or.inr tendsto_comap

lemma is_o_const_id_at_top (c : E'') : (Œª x : ‚Ñù, c) =o[at_top] id :=
is_o_const_left.2 $ or.inr tendsto_abs_at_top_at_top

lemma is_o_const_id_at_bot (c : E'') : (Œª x : ‚Ñù, c) =o[at_bot] id :=
is_o_const_left.2 $ or.inr tendsto_abs_at_bot_at_top

/-!
### Eventually (u / v) * v = u

If `u` and `v` are linked by an `is_O_with` relation, then we
eventually have `(u / v) * v = u`, even if `v` vanishes.
-/

section eventually_mul_div_cancel

variables {u v : Œ± ‚Üí ùïú}

lemma is_O_with.eventually_mul_div_cancel (h : is_O_with c l u v) :
  (u / v) * v =·∂†[l] u :=
eventually.mono h.bound (Œª y hy, div_mul_cancel_of_imp $ Œª hv, by simpa [hv] using hy)

/-- If `u = O(v)` along `l`, then `(u / v) * v = u` eventually at `l`. -/
lemma is_O.eventually_mul_div_cancel (h : u =O[l] v) :  (u / v) * v =·∂†[l] u :=
let ‚ü®c, hc‚ü© := h.is_O_with in hc.eventually_mul_div_cancel

/-- If `u = o(v)` along `l`, then `(u / v) * v = u` eventually at `l`. -/
lemma is_o.eventually_mul_div_cancel (h : u =o[l] v) : (u / v) * v =·∂†[l] u :=
(h.forall_is_O_with zero_lt_one).eventually_mul_div_cancel

end eventually_mul_div_cancel

/-! ### Equivalent definitions of the form `‚àÉ œÜ, u =·∂†[l] œÜ * v` in a `normed_field`. -/

section exists_mul_eq

variables {u v : Œ± ‚Üí ùïú}

/-- If `‚ÄñœÜ‚Äñ` is eventually bounded by `c`, and `u =·∂†[l] œÜ * v`, then we have `is_O_with c u v l`.
    This does not require any assumptions on `c`, which is why we keep this version along with
    `is_O_with_iff_exists_eq_mul`. -/
lemma is_O_with_of_eq_mul (œÜ : Œ± ‚Üí ùïú) (hœÜ : ‚àÄ·∂† x in l, ‚ÄñœÜ x‚Äñ ‚â§ c) (h : u =·∂†[l] œÜ * v) :
  is_O_with c l u v :=
begin
  unfold is_O_with,
  refine h.symm.rw (Œª x a, ‚Äña‚Äñ ‚â§ c * ‚Äñv x‚Äñ) (hœÜ.mono $ Œª x hx, _),
  simp only [norm_mul, pi.mul_apply],
  exact mul_le_mul_of_nonneg_right hx (norm_nonneg _)
end

lemma is_O_with_iff_exists_eq_mul (hc : 0 ‚â§ c) :
  is_O_with c l u v ‚Üî ‚àÉ (œÜ : Œ± ‚Üí ùïú) (hœÜ : ‚àÄ·∂† x in l, ‚ÄñœÜ x‚Äñ ‚â§ c), u =·∂†[l] œÜ * v :=
begin
  split,
  { intro h,
    use (Œª x, u x / v x),
    refine ‚ü®eventually.mono h.bound (Œª y hy, _), h.eventually_mul_div_cancel.symm‚ü©,
    simpa using div_le_of_nonneg_of_le_mul (norm_nonneg _) hc hy },
  { rintros ‚ü®œÜ, hœÜ, h‚ü©,
    exact is_O_with_of_eq_mul œÜ hœÜ h }
end

lemma is_O_with.exists_eq_mul (h : is_O_with c l u v) (hc : 0 ‚â§ c) :
  ‚àÉ (œÜ : Œ± ‚Üí ùïú) (hœÜ : ‚àÄ·∂† x in l, ‚ÄñœÜ x‚Äñ ‚â§ c), u =·∂†[l] œÜ * v :=
(is_O_with_iff_exists_eq_mul hc).mp h

lemma is_O_iff_exists_eq_mul :
  u =O[l] v ‚Üî ‚àÉ (œÜ : Œ± ‚Üí ùïú) (hœÜ : l.is_bounded_under (‚â§) (norm ‚àò œÜ)), u =·∂†[l] œÜ * v :=
begin
  split,
  { rintros h,
    rcases h.exists_nonneg with ‚ü®c, hnnc, hc‚ü©,
    rcases hc.exists_eq_mul hnnc with ‚ü®œÜ, hœÜ, huvœÜ‚ü©,
    exact ‚ü®œÜ, ‚ü®c, hœÜ‚ü©, huvœÜ‚ü© },
  { rintros ‚ü®œÜ, ‚ü®c, hœÜ‚ü©, huvœÜ‚ü©,
    exact is_O_iff_is_O_with.2 ‚ü®c, is_O_with_of_eq_mul œÜ hœÜ huvœÜ‚ü© }
end

alias is_O_iff_exists_eq_mul ‚Üî is_O.exists_eq_mul _

lemma is_o_iff_exists_eq_mul :
  u =o[l] v ‚Üî ‚àÉ (œÜ : Œ± ‚Üí ùïú) (hœÜ : tendsto œÜ l (ùìù 0)), u =·∂†[l] œÜ * v :=
begin
  split,
  { exact Œª h, ‚ü®Œª x, u x / v x, h.tendsto_div_nhds_zero, h.eventually_mul_div_cancel.symm‚ü© },
  { unfold is_o, rintros ‚ü®œÜ, hœÜ, huvœÜ‚ü© c hpos,
    rw normed_add_comm_group.tendsto_nhds_zero at hœÜ,
    exact is_O_with_of_eq_mul _ ((hœÜ c hpos).mono $ Œª x, le_of_lt)  huvœÜ }
end

alias is_o_iff_exists_eq_mul ‚Üî is_o.exists_eq_mul _

end exists_mul_eq

/-! ### Miscellanous lemmas -/

theorem div_is_bounded_under_of_is_O {Œ± : Type*} {l : filter Œ±}
  {f g : Œ± ‚Üí ùïú} (h : f =O[l] g) :
  is_bounded_under (‚â§) l (Œª x, ‚Äñf x / g x‚Äñ) :=
begin
  obtain ‚ü®c, h‚ÇÄ, hc‚ü© := h.exists_nonneg,
  refine ‚ü®c, eventually_map.2 (hc.bound.mono (Œª x hx, _))‚ü©,
  rw [norm_div],
  exact div_le_of_nonneg_of_le_mul (norm_nonneg _) h‚ÇÄ hx,
end

theorem is_O_iff_div_is_bounded_under {Œ± : Type*} {l : filter Œ±}
  {f g : Œ± ‚Üí ùïú} (hgf : ‚àÄ·∂† x in l, g x = 0 ‚Üí f x = 0) :
  f =O[l] g ‚Üî is_bounded_under (‚â§) l (Œª x, ‚Äñf x / g x‚Äñ) :=
begin
  refine ‚ü®div_is_bounded_under_of_is_O, Œª h, _‚ü©,
  obtain ‚ü®c, hc‚ü© := h,
  simp only [eventually_map, norm_div] at hc,
  refine is_O.of_bound c (hc.mp $ hgf.mono (Œª x hx‚ÇÅ hx‚ÇÇ, _)),
  by_cases hgx : g x = 0,
  { simp [hx‚ÇÅ hgx, hgx] },
  { exact (div_le_iff (norm_pos_iff.2 hgx)).mp hx‚ÇÇ },
end

theorem is_O_of_div_tendsto_nhds {Œ± : Type*} {l : filter Œ±}
  {f g : Œ± ‚Üí ùïú} (hgf : ‚àÄ·∂† x in l, g x = 0 ‚Üí f x = 0)
  (c : ùïú) (H : filter.tendsto (f / g) l (ùìù c)) :
  f =O[l] g :=
(is_O_iff_div_is_bounded_under hgf).2 $ H.norm.is_bounded_under_le

lemma is_o.tendsto_zero_of_tendsto {Œ± E ùïú : Type*} [normed_add_comm_group E] [normed_field ùïú]
  {u : Œ± ‚Üí E} {v : Œ± ‚Üí ùïú} {l : filter Œ±} {y : ùïú} (huv : u =o[l] v) (hv : tendsto v l (ùìù y)) :
  tendsto u l (ùìù 0) :=
begin
  suffices h : u =o[l] (Œª x, (1 : ùïú)),
  { rwa is_o_one_iff at h },
  exact huv.trans_is_O (hv.is_O_one ùïú),
end

theorem is_o_pow_pow {m n : ‚Ñï} (h : m < n) :
  (Œª x : ùïú, x ^ n) =o[ùìù 0] (Œª x, x ^ m) :=
begin
  rcases lt_iff_exists_add.1 h with ‚ü®p, hp0 : 0 < p, rfl‚ü©,
  suffices : (Œª x : ùïú, x ^ m * x ^ p) =o[ùìù 0] (Œª x, x ^ m * 1 ^ p),
    by simpa only [pow_add, one_pow, mul_one],
  exact is_O.mul_is_o (is_O_refl _ _) (is_o.pow ((is_o_one_iff _).2 tendsto_id) hp0)
end

theorem is_o_norm_pow_norm_pow {m n : ‚Ñï} (h : m < n) :
  (Œª x : E', ‚Äñx‚Äñ^n) =o[ùìù 0] (Œª x, ‚Äñx‚Äñ^m) :=
(is_o_pow_pow h).comp_tendsto tendsto_norm_zero

theorem is_o_pow_id {n : ‚Ñï} (h : 1 < n) :
  (Œª x : ùïú, x^n) =o[ùìù 0] (Œª x, x) :=
by { convert is_o_pow_pow h, simp only [pow_one] }

theorem is_o_norm_pow_id {n : ‚Ñï} (h : 1 < n) :
  (Œª x : E', ‚Äñx‚Äñ^n) =o[ùìù 0] (Œª x, x) :=
by simpa only [pow_one, is_o_norm_right] using @is_o_norm_pow_norm_pow E' _ _ _ h

lemma is_O.eq_zero_of_norm_pow_within {f : E'' ‚Üí F''} {s : set E''} {x‚ÇÄ : E''} {n : ‚Ñï}
  (h : f =O[ùìù[s] x‚ÇÄ] Œª x, ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hx‚ÇÄ : x‚ÇÄ ‚àà s) (hn : 0 < n) : f x‚ÇÄ = 0 :=
mem_of_mem_nhds_within hx‚ÇÄ h.eq_zero_imp $ by simp_rw [sub_self, norm_zero, zero_pow hn]

lemma is_O.eq_zero_of_norm_pow {f : E'' ‚Üí F''} {x‚ÇÄ : E''} {n : ‚Ñï}
  (h : f =O[ùìù x‚ÇÄ] Œª x, ‚Äñx - x‚ÇÄ‚Äñ ^ n) (hn : 0 < n) : f x‚ÇÄ = 0 :=
by { rw [‚Üê nhds_within_univ] at h, exact h.eq_zero_of_norm_pow_within (mem_univ _) hn }

lemma is_o_pow_sub_pow_sub (x‚ÇÄ : E') {n m : ‚Ñï} (h : n < m) :
    (Œª x, ‚Äñx - x‚ÇÄ‚Äñ ^ m) =o[ùìù x‚ÇÄ] Œª x, ‚Äñx - x‚ÇÄ‚Äñ^n :=
begin
  have : tendsto (Œª x, ‚Äñx - x‚ÇÄ‚Äñ) (ùìù x‚ÇÄ) (ùìù 0),
  { apply tendsto_norm_zero.comp,
    rw ‚Üê sub_self x‚ÇÄ,
    exact tendsto_id.sub tendsto_const_nhds },
  exact (is_o_pow_pow h).comp_tendsto this
end

lemma is_o_pow_sub_sub (x‚ÇÄ : E') {m : ‚Ñï} (h : 1 < m) :
    (Œª x, ‚Äñx - x‚ÇÄ‚Äñ^m) =o[ùìù x‚ÇÄ] Œª x, x - x‚ÇÄ :=
by simpa only [is_o_norm_right, pow_one] using is_o_pow_sub_pow_sub x‚ÇÄ h

theorem is_O_with.right_le_sub_of_lt_1 {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E'} (h : is_O_with c l f‚ÇÅ f‚ÇÇ) (hc : c < 1) :
  is_O_with (1 / (1 - c)) l f‚ÇÇ (Œªx, f‚ÇÇ x - f‚ÇÅ x) :=
is_O_with.of_bound $ mem_of_superset h.bound $ Œª x hx,
begin
  simp only [mem_set_of_eq] at hx ‚ä¢,
  rw [mul_comm, one_div, ‚Üê div_eq_mul_inv, le_div_iff, mul_sub, mul_one, mul_comm],
  { exact le_trans (sub_le_sub_left hx _) (norm_sub_norm_le _ _) },
  { exact sub_pos.2 hc }
end

theorem is_O_with.right_le_add_of_lt_1 {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E'} (h : is_O_with c l f‚ÇÅ f‚ÇÇ) (hc : c < 1) :
  is_O_with (1 / (1 - c)) l f‚ÇÇ (Œªx, f‚ÇÅ x + f‚ÇÇ x) :=
(h.neg_right.right_le_sub_of_lt_1 hc).neg_right.of_neg_left.congr rfl (Œª x, rfl)
  (Œª x, by rw [neg_sub, sub_neg_eq_add])

theorem is_o.right_is_O_sub {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E'} (h : f‚ÇÅ =o[l] f‚ÇÇ) :
  f‚ÇÇ =O[l] (Œªx, f‚ÇÇ x - f‚ÇÅ x) :=
((h.def' one_half_pos).right_le_sub_of_lt_1 one_half_lt_one).is_O

theorem is_o.right_is_O_add {f‚ÇÅ f‚ÇÇ : Œ± ‚Üí E'} (h : f‚ÇÅ =o[l] f‚ÇÇ) :
  f‚ÇÇ =O[l] (Œªx, f‚ÇÅ x + f‚ÇÇ x) :=
((h.def' one_half_pos).right_le_add_of_lt_1 one_half_lt_one).is_O

/-- If `f x = O(g x)` along `cofinite`, then there exists a positive constant `C` such that
`‚Äñf x‚Äñ ‚â§ C * ‚Äñg x‚Äñ` whenever `g x ‚â† 0`. -/
theorem bound_of_is_O_cofinite (h : f =O[cofinite] g'') :
  ‚àÉ C > 0, ‚àÄ ‚¶Éx‚¶Ñ, g'' x ‚â† 0 ‚Üí ‚Äñf x‚Äñ ‚â§ C * ‚Äñg'' x‚Äñ :=
begin
  rcases h.exists_pos with ‚ü®C, C‚ÇÄ, hC‚ü©,
  rw [is_O_with, eventually_cofinite] at hC,
  rcases (hC.to_finset.image (Œª x, ‚Äñf x‚Äñ / ‚Äñg'' x‚Äñ)).exists_le with ‚ü®C', hC'‚ü©,
  have : ‚àÄ x, C * ‚Äñg'' x‚Äñ < ‚Äñf x‚Äñ ‚Üí ‚Äñf x‚Äñ / ‚Äñg'' x‚Äñ ‚â§ C', by simpa using hC',
  refine ‚ü®max C C', lt_max_iff.2 (or.inl C‚ÇÄ), Œª x h‚ÇÄ, _‚ü©,
  rw [max_mul_of_nonneg _ _ (norm_nonneg _), le_max_iff, or_iff_not_imp_left, not_le],
  exact Œª hx, (div_le_iff (norm_pos_iff.2 h‚ÇÄ)).1 (this _ hx)
end

theorem is_O_cofinite_iff (h : ‚àÄ x, g'' x = 0 ‚Üí f'' x = 0) :
  f'' =O[cofinite] g'' ‚Üî ‚àÉ C, ‚àÄ x, ‚Äñf'' x‚Äñ ‚â§ C * ‚Äñg'' x‚Äñ :=
‚ü®Œª h', let ‚ü®C, C‚ÇÄ, hC‚ü© := bound_of_is_O_cofinite h' in
  ‚ü®C, Œª x, if hx : g'' x = 0 then by simp [h _ hx, hx] else hC hx‚ü©,
  Œª h, (is_O_top.2 h).mono le_top‚ü©

theorem bound_of_is_O_nat_at_top {f : ‚Ñï ‚Üí E} {g'' : ‚Ñï ‚Üí E''} (h : f =O[at_top] g'') :
  ‚àÉ C > 0, ‚àÄ ‚¶Éx‚¶Ñ, g'' x ‚â† 0 ‚Üí ‚Äñf x‚Äñ ‚â§ C * ‚Äñg'' x‚Äñ :=
bound_of_is_O_cofinite $ by rwa nat.cofinite_eq_at_top

theorem is_O_nat_at_top_iff {f : ‚Ñï ‚Üí E''} {g : ‚Ñï ‚Üí F''} (h : ‚àÄ x, g x = 0 ‚Üí f x = 0) :
  f =O[at_top] g ‚Üî ‚àÉ C, ‚àÄ x, ‚Äñf x‚Äñ ‚â§ C * ‚Äñg x‚Äñ :=
by rw [‚Üê nat.cofinite_eq_at_top, is_O_cofinite_iff h]

theorem is_O_one_nat_at_top_iff {f : ‚Ñï ‚Üí E''} :
  f =O[at_top] (Œª n, 1 : ‚Ñï ‚Üí ‚Ñù) ‚Üî ‚àÉ C, ‚àÄ n, ‚Äñf n‚Äñ ‚â§ C :=
iff.trans (is_O_nat_at_top_iff (Œª n h, (one_ne_zero h).elim)) $
  by simp only [norm_one, mul_one]

theorem is_O_with_pi {Œπ : Type*} [fintype Œπ] {E' : Œπ ‚Üí Type*} [Œ† i, normed_add_comm_group (E' i)]
  {f : Œ± ‚Üí Œ† i, E' i} {C : ‚Ñù} (hC : 0 ‚â§ C) :
  is_O_with C l f g' ‚Üî ‚àÄ i, is_O_with C l (Œª x, f x i) g' :=
have ‚àÄ x, 0 ‚â§ C * ‚Äñg' x‚Äñ, from Œª x, mul_nonneg hC (norm_nonneg _),
by simp only [is_O_with_iff, pi_norm_le_iff_of_nonneg (this _), eventually_all]

@[simp] theorem is_O_pi {Œπ : Type*} [fintype Œπ] {E' : Œπ ‚Üí Type*} [Œ† i, normed_add_comm_group (E' i)]
  {f : Œ± ‚Üí Œ† i, E' i} :
  f =O[l] g' ‚Üî ‚àÄ i, (Œª x, f x i) =O[l] g' :=
begin
  simp only [is_O_iff_eventually_is_O_with, ‚Üê eventually_all],
  exact eventually_congr (eventually_at_top.2 ‚ü®0, Œª c, is_O_with_pi‚ü©)
end

@[simp] theorem is_o_pi {Œπ : Type*} [fintype Œπ] {E' : Œπ ‚Üí Type*} [Œ† i, normed_add_comm_group (E' i)]
  {f : Œ± ‚Üí Œ† i, E' i} :
  f =o[l] g' ‚Üî ‚àÄ i, (Œª x, f x i) =o[l] g' :=
begin
  simp only [is_o, is_O_with_pi, le_of_lt] { contextual := tt },
  exact ‚ü®Œª h i c hc, h hc i, Œª h c hc i, h i hc‚ü©
end

end asymptotics

open asymptotics

lemma summable_of_is_O {Œπ E} [normed_add_comm_group E] [complete_space E] {f : Œπ ‚Üí E} {g : Œπ ‚Üí ‚Ñù}
  (hg : summable g) (h : f =O[cofinite] g) : summable f :=
let ‚ü®C, hC‚ü© := h.is_O_with in
summable_of_norm_bounded_eventually (Œª x, C * ‚Äñg x‚Äñ) (hg.abs.mul_left _) hC.bound

lemma summable_of_is_O_nat {E} [normed_add_comm_group E] [complete_space E] {f : ‚Ñï ‚Üí E} {g : ‚Ñï ‚Üí ‚Ñù}
  (hg : summable g) (h : f =O[at_top] g) : summable f :=
summable_of_is_O hg $ nat.cofinite_eq_at_top.symm ‚ñ∏ h

namespace local_homeomorph

variables {Œ± : Type*} {Œ≤ : Type*} [topological_space Œ±] [topological_space Œ≤]

variables {E : Type*} [has_norm E] {F : Type*} [has_norm F]

/-- Transfer `is_O_with` over a `local_homeomorph`. -/
lemma is_O_with_congr (e : local_homeomorph Œ± Œ≤) {b : Œ≤} (hb : b ‚àà e.target)
  {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} {C : ‚Ñù} :
  is_O_with C (ùìù b) f g ‚Üî is_O_with C (ùìù (e.symm b)) (f ‚àò e) (g ‚àò e) :=
‚ü®Œª h, h.comp_tendsto $
  by { convert e.continuous_at (e.map_target hb), exact (e.right_inv hb).symm },
  Œª h, (h.comp_tendsto (e.continuous_at_symm hb)).congr' rfl
    ((e.eventually_right_inverse hb).mono $ Œª x hx, congr_arg f hx)
    ((e.eventually_right_inverse hb).mono $ Œª x hx, congr_arg g hx)‚ü©

/-- Transfer `is_O` over a `local_homeomorph`. -/
lemma is_O_congr (e : local_homeomorph Œ± Œ≤) {b : Œ≤} (hb : b ‚àà e.target) {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} :
  f =O[ùìù b] g ‚Üî (f ‚àò e) =O[ùìù (e.symm b)] (g ‚àò e) :=
by { unfold is_O, exact exists_congr (Œª C, e.is_O_with_congr hb) }

/-- Transfer `is_o` over a `local_homeomorph`. -/
lemma is_o_congr (e : local_homeomorph Œ± Œ≤) {b : Œ≤} (hb : b ‚àà e.target) {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} :
  f =o[ùìù b] g ‚Üî (f ‚àò e) =o[ùìù (e.symm b)] (g ‚àò e) :=
by { unfold is_o, exact forall‚ÇÇ_congr (Œª c hc, e.is_O_with_congr hb) }

end local_homeomorph

namespace homeomorph

variables {Œ± : Type*} {Œ≤ : Type*} [topological_space Œ±] [topological_space Œ≤]

variables {E : Type*} [has_norm E] {F : Type*} [has_norm F]

open asymptotics

/-- Transfer `is_O_with` over a `homeomorph`. -/
lemma is_O_with_congr (e : Œ± ‚âÉ‚Çú Œ≤) {b : Œ≤} {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} {C : ‚Ñù} :
  is_O_with C (ùìù b) f g ‚Üî is_O_with C (ùìù (e.symm b)) (f ‚àò e) (g ‚àò e) :=
e.to_local_homeomorph.is_O_with_congr trivial

/-- Transfer `is_O` over a `homeomorph`. -/
lemma is_O_congr (e : Œ± ‚âÉ‚Çú Œ≤) {b : Œ≤} {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} :
  f =O[ùìù b] g ‚Üî (f ‚àò e) =O[ùìù (e.symm b)] (g ‚àò e) :=
by { unfold is_O, exact exists_congr (Œª C, e.is_O_with_congr) }

/-- Transfer `is_o` over a `homeomorph`. -/
lemma is_o_congr (e : Œ± ‚âÉ‚Çú Œ≤) {b : Œ≤} {f : Œ≤ ‚Üí E} {g : Œ≤ ‚Üí F} :
  f =o[ùìù b] g ‚Üî (f ‚àò e) =o[ùìù (e.symm b)] (g ‚àò e) :=
by { unfold is_o, exact forall‚ÇÇ_congr (Œª c hc, e.is_O_with_congr) }

end homeomorph
