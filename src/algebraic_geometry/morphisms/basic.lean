/-
Copyright (c) 2022 Andrew Yang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Andrew Yang
-/
import algebraic_geometry.AffineScheme
import algebraic_geometry.pullbacks
import category_theory.morphism_property

/-!
# Properties of morphisms between Schemes

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

We provide the basic framework for talking about properties of morphisms between Schemes.

A `morphism_property Scheme` is a predicate on morphisms between schemes, and an
`affine_target_morphism_property` is a predicate on morphisms into affine schemes. Given a
`P : affine_target_morphism_property`, we may construct a `morphism_property` called
`target_affine_locally P` that holds for `f : X ‚ü∂ Y` whenever `P` holds for the
restriction of `f` on every affine open subset of `Y`.

## Main definitions

- `algebraic_geometry.affine_target_morphism_property.is_local`: We say that `P.is_local` if `P`
satisfies the assumptions of the affine communication lemma
(`algebraic_geometry.of_affine_open_cover`). That is,
1. `P` respects isomorphisms.
2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ Y.basic_open r` for any
  global section `r`.
3. If `P` holds for `f ‚à£_ Y.basic_open r` for all `r` in a spanning set of the global sections,
  then `P` holds for `f`.

- `algebraic_geometry.property_is_local_at_target`: We say that `property_is_local_at_target P` for
`P : morphism_property Scheme` if
1. `P` respects isomorphisms.
2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ U` for any `U`.
3. If `P` holds for `f ‚à£_ U` for an open cover `U` of `Y`, then `P` holds for `f`.

## Main results

- `algebraic_geometry.affine_target_morphism_property.is_local.affine_open_cover_tfae`:
  If `P.is_local`, then `target_affine_locally P f` iff there exists an affine cover `{ U·µ¢ }` of `Y`
  such that `P` holds for `f ‚à£_ U·µ¢`.
- `algebraic_geometry.affine_target_morphism_property.is_local_of_open_cover_imply`:
  If the existance of an affine cover `{ U·µ¢ }` of `Y` such that `P` holds for `f ‚à£_ U·µ¢` implies
  `target_affine_locally P f`, then `P.is_local`.
- `algebraic_geometry.affine_target_morphism_property.is_local.affine_target_iff`:
  If `Y` is affine and `f : X ‚ü∂ Y`, then `target_affine_locally P f ‚Üî P f` provided `P.is_local`.
- `algebraic_geometry.affine_target_morphism_property.is_local.target_affine_locally_is_local` :
  If `P.is_local`, then `property_is_local_at_target (target_affine_locally P)`.
- `algebraic_geometry.property_is_local_at_target.open_cover_tfae`:
  If `property_is_local_at_target P`, then `P f` iff there exists an open cover `{ U·µ¢ }` of `Y`
  such that `P` holds for `f ‚à£_ U·µ¢`.

These results should not be used directly, and should be ported to each property that is local.

-/

universe u

open topological_space category_theory category_theory.limits opposite

noncomputable theory

namespace algebraic_geometry

/-- An `affine_target_morphism_property` is a class of morphisms from an arbitrary scheme into an
affine scheme. -/
def affine_target_morphism_property := ‚àÄ ‚¶ÉX Y : Scheme‚¶Ñ (f : X ‚ü∂ Y) [is_affine Y], Prop

/-- `is_iso` as a `morphism_property`. -/
protected def Scheme.is_iso : morphism_property Scheme := @is_iso Scheme _

/-- `is_iso` as an `affine_morphism_property`. -/
protected def Scheme.affine_target_is_iso : affine_target_morphism_property :=
Œª X Y f H, is_iso f

instance : inhabited affine_target_morphism_property := ‚ü®Scheme.affine_target_is_iso‚ü©

/-- A `affine_target_morphism_property` can be extended to a `morphism_property` such that it
*never* holds when the target is not affine -/
def affine_target_morphism_property.to_property (P : affine_target_morphism_property) :
  morphism_property Scheme :=
Œª X Y f, ‚àÉ h, @@P f h

lemma affine_target_morphism_property.to_property_apply (P : affine_target_morphism_property)
  {X Y : Scheme} (f : X ‚ü∂ Y) [is_affine Y] :
  P.to_property f ‚Üî P f := by { delta affine_target_morphism_property.to_property, simp [*] }

lemma affine_cancel_left_is_iso {P : affine_target_morphism_property}
  (hP : P.to_property.respects_iso) {X Y Z : Scheme} (f : X ‚ü∂ Y)
    (g : Y ‚ü∂ Z) [is_iso f] [is_affine Z] : P (f ‚â´ g) ‚Üî P g :=
by rw [‚Üê P.to_property_apply, ‚Üê P.to_property_apply, hP.cancel_left_is_iso]

lemma affine_cancel_right_is_iso
  {P : affine_target_morphism_property} (hP : P.to_property.respects_iso) {X Y Z : Scheme}
    (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [is_iso g] [is_affine Z] [is_affine Y] : P (f ‚â´ g) ‚Üî P f :=
by rw [‚Üê P.to_property_apply, ‚Üê P.to_property_apply, hP.cancel_right_is_iso]

lemma affine_target_morphism_property.respects_iso_mk {P : affine_target_morphism_property}
  (h‚ÇÅ : ‚àÄ {X Y Z} (e : X ‚âÖ Y) (f : Y ‚ü∂ Z) [is_affine Z], by exactI P f ‚Üí P (e.hom ‚â´ f))
  (h‚ÇÇ : ‚àÄ {X Y Z} (e : Y ‚âÖ Z) (f : X ‚ü∂ Y) [h : is_affine Y],
     by exactI P f ‚Üí @@P (f ‚â´ e.hom) (is_affine_of_iso e.inv)) : P.to_property.respects_iso :=
begin
  split,
  { rintros X Y Z e f ‚ü®a, h‚ü©, exactI ‚ü®a, h‚ÇÅ e f h‚ü© },
  { rintros X Y Z e f ‚ü®a, h‚ü©, exactI ‚ü®is_affine_of_iso e.inv, h‚ÇÇ e f h‚ü© },
end

/-- For a `P : affine_target_morphism_property`, `target_affine_locally P` holds for
`f : X ‚ü∂ Y` whenever `P` holds for the restriction of `f` on every affine open subset of `Y`. -/
def target_affine_locally (P : affine_target_morphism_property) : morphism_property Scheme :=
  Œª {X Y : Scheme} (f : X ‚ü∂ Y), ‚àÄ (U : Y.affine_opens), @@P (f ‚à£_ U) U.prop

lemma is_affine_open.map_is_iso {X Y : Scheme} {U : opens Y.carrier} (hU : is_affine_open U)
  (f : X ‚ü∂ Y) [is_iso f] : is_affine_open ((opens.map f.1.base).obj U) :=
begin
  haveI : is_affine _ := hU,
  exact is_affine_of_iso (f ‚à£_ U),
end

lemma target_affine_locally_respects_iso {P : affine_target_morphism_property}
  (hP : P.to_property.respects_iso) : (target_affine_locally P).respects_iso :=
begin
  split,
  { introv H U,
    rw [morphism_restrict_comp, affine_cancel_left_is_iso hP],
    exact H U },
  { introv H,
    rintro ‚ü®U, hU : is_affine_open U‚ü©, dsimp,
    haveI : is_affine _ := hU,
    haveI : is_affine _ := hU.map_is_iso e.hom,
    rw [morphism_restrict_comp, affine_cancel_right_is_iso hP],
    exact H ‚ü®(opens.map e.hom.val.base).obj U, hU.map_is_iso e.hom‚ü© }
end

/--
We say that `P : affine_target_morphism_property` is a local property if
1. `P` respects isomorphisms.
2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ Y.basic_open r` for any
  global section `r`.
3. If `P` holds for `f ‚à£_ Y.basic_open r` for all `r` in a spanning set of the global sections,
  then `P` holds for `f`.
-/
structure affine_target_morphism_property.is_local (P : affine_target_morphism_property) : Prop :=
(respects_iso : P.to_property.respects_iso)
(to_basic_open : ‚àÄ {X Y : Scheme} [is_affine Y] (f : X ‚ü∂ Y) (r : Y.presheaf.obj $ op ‚ä§),
  by exactI P f ‚Üí
    @@P (f ‚à£_ (Y.basic_open r)) ((top_is_affine_open Y).basic_open_is_affine _))
(of_basic_open_cover : ‚àÄ {X Y : Scheme} [is_affine Y] (f : X ‚ü∂ Y)
  (s : finset (Y.presheaf.obj $ op ‚ä§)) (hs : ideal.span (s : set (Y.presheaf.obj $ op ‚ä§)) = ‚ä§),
  by exactI (‚àÄ (r : s), @@P (f ‚à£_ (Y.basic_open r.1))
    ((top_is_affine_open Y).basic_open_is_affine _)) ‚Üí P f)

lemma target_affine_locally_of_open_cover {P : affine_target_morphism_property}
  (hP : P.is_local)
  {X Y : Scheme} (f : X ‚ü∂ Y) (ùí∞ : Y.open_cover) [‚àÄ i, is_affine (ùí∞.obj i)]
  (hùí∞ : ‚àÄ i, P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i)) :
    target_affine_locally P f :=
begin
  classical,
  let S := Œª i, (‚ü®‚ü®set.range (ùí∞.map i).1.base, (ùí∞.is_open i).base_open.open_range‚ü©,
    range_is_affine_open_of_open_immersion (ùí∞.map i)‚ü© : Y.affine_opens),
  intro U,
  apply of_affine_open_cover U (set.range S),
  { intros U r h,
    haveI : is_affine _ := U.2,
    have := hP.2 (f ‚à£_ U.1),
    replace this := this (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top).op r) h,
    rw ‚Üê P.to_property_apply at this ‚ä¢,
    exact (hP.1.arrow_mk_iso_iff (morphism_restrict_restrict_basic_open f _ r)).mp this },
  { intros U s hs H,
    haveI : is_affine _ := U.2,
    apply hP.3 (f ‚à£_ U.1) (s.image (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top).op)),
    { apply_fun ideal.comap (Y.presheaf.map (eq_to_hom U.1.open_embedding_obj_top.symm).op) at hs,
      rw ideal.comap_top at hs,
      rw ‚Üê hs,
      simp only [eq_to_hom_op, eq_to_hom_map, finset.coe_image],
      have : ‚àÄ {R S : CommRing} (e : S = R) (s : set S),
        (by exactI ideal.span (eq_to_hom e '' s) = ideal.comap (eq_to_hom e.symm) (ideal.span s)),
      { intros, subst e, simpa },
      apply this },
    { rintro ‚ü®r, hr‚ü©,
      obtain ‚ü®r, hr', rfl‚ü© := finset.mem_image.mp hr,
      simp_rw ‚Üê P.to_property_apply at ‚ä¢ H,
      exact
        (hP.1.arrow_mk_iso_iff (morphism_restrict_restrict_basic_open f _ r)).mpr (H ‚ü®r, hr'‚ü©) } },
  { rw set.eq_univ_iff_forall,
    simp only [set.mem_Union],
    intro x,
    exact ‚ü®‚ü®_, ‚ü®ùí∞.f x, rfl‚ü©‚ü©, ùí∞.covers x‚ü© },
  { rintro ‚ü®_, i, rfl‚ü©,
    simp_rw ‚Üê P.to_property_apply at ‚ä¢ hùí∞,
    exact (hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)).mpr (hùí∞ i) },
end

lemma affine_target_morphism_property.is_local.affine_open_cover_tfae
  {P : affine_target_morphism_property}
  (hP : P.is_local) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) :
  tfae [target_affine_locally P f,
    ‚àÉ (ùí∞ : Scheme.open_cover.{u} Y) [‚àÄ i, is_affine (ùí∞.obj i)], ‚àÄ (i : ùí∞.J),
      by exactI P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i),
    ‚àÄ (ùí∞ : Scheme.open_cover.{u} Y) [‚àÄ i, is_affine (ùí∞.obj i)] (i : ùí∞.J),
      by exactI P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i),
    ‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [is_affine U] [is_open_immersion g],
      by exactI P (pullback.snd : pullback f g ‚ü∂ U),
    ‚àÉ {Œπ : Type u} (U : Œπ ‚Üí opens Y.carrier) (hU : supr U = ‚ä§) (hU' : ‚àÄ i, is_affine_open (U i)),
      ‚àÄ i, @@P (f ‚à£_ (U i)) (hU' i)] :=
begin
  tfae_have : 1 ‚Üí 4,
  { intros H U g h‚ÇÅ h‚ÇÇ,
    resetI,
    replace H := H ‚ü®‚ü®_, h‚ÇÇ.base_open.open_range‚ü©,
      range_is_affine_open_of_open_immersion g‚ü©,
    rw ‚Üê P.to_property_apply at H ‚ä¢,
    rwa ‚Üê hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _) },
  tfae_have : 4 ‚Üí 3,
  { intros H ùí∞ hùí∞ i,
    resetI,
    apply H },
  tfae_have : 3 ‚Üí 2,
  { exact Œª H, ‚ü®Y.affine_cover, infer_instance, H Y.affine_cover‚ü© },
  tfae_have : 2 ‚Üí 1,
  { rintro ‚ü®ùí∞, hùí∞, H‚ü©, exactI target_affine_locally_of_open_cover hP f ùí∞ H },
  tfae_have : 5 ‚Üí 2,
  { rintro ‚ü®Œπ, U, hU, hU', H‚ü©,
    refine ‚ü®Y.open_cover_of_supr_eq_top U hU, hU', _‚ü©,
    intro i,
    specialize H i,
    rw [‚Üê P.to_property_apply, ‚Üê hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _)],
    rw ‚Üê P.to_property_apply at H,
    convert H,
    all_goals { ext1, exact subtype.range_coe } },
  tfae_have : 1 ‚Üí 5,
  { intro H,
    refine ‚ü®Y.carrier, Œª x, (Y.affine_cover.map x).opens_range, _,
      Œª i, range_is_affine_open_of_open_immersion _, _‚ü©,
    { rw eq_top_iff, intros x _, erw opens.mem_supr, exact‚ü®x, Y.affine_cover.covers x‚ü© },
    { intro i, exact H ‚ü®_, range_is_affine_open_of_open_immersion _‚ü© } },
  tfae_finish
end

lemma affine_target_morphism_property.is_local_of_open_cover_imply
  (P : affine_target_morphism_property) (hP : P.to_property.respects_iso)
  (H : ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y),
    (‚àÉ (ùí∞ : Scheme.open_cover.{u} Y) [‚àÄ i, is_affine (ùí∞.obj i)], ‚àÄ (i : ùí∞.J),
      by exactI P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i)) ‚Üí
    (‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [is_affine U] [is_open_immersion g],
      by exactI P (pullback.snd : pullback f g ‚ü∂ U))) : P.is_local :=
begin
  refine ‚ü®hP, _, _‚ü©,
  { introv h,
    resetI,
    haveI : is_affine _ := (top_is_affine_open Y).basic_open_is_affine r,
    delta morphism_restrict,
    rw affine_cancel_left_is_iso hP,
    refine @@H f ‚ü®Scheme.open_cover_of_is_iso (ùüô Y), _, _‚ü© (Y.of_restrict _) _inst _,
    { intro i, dsimp, apply_instance },
    { intro i, dsimp,
      rwa [‚Üê category.comp_id pullback.snd, ‚Üê pullback.condition, affine_cancel_left_is_iso hP] } },
  { introv hs hs',
    resetI,
    replace hs := ((top_is_affine_open Y).basic_open_union_eq_self_iff _).mpr hs,
    have := H f ‚ü®Y.open_cover_of_supr_eq_top _ hs, _, _‚ü© (ùüô _),
    rwa [‚Üê category.comp_id pullback.snd, ‚Üê pullback.condition,
      affine_cancel_left_is_iso hP] at this,
    { intro i, exact (top_is_affine_open Y).basic_open_is_affine _ },
    { rintro (i : s),
      specialize hs' i,
      haveI : is_affine _ := (top_is_affine_open Y).basic_open_is_affine i.1,
      delta morphism_restrict at hs',
      rwa affine_cancel_left_is_iso hP at hs' } }
end

lemma affine_target_morphism_property.is_local.affine_open_cover_iff
  {P : affine_target_morphism_property} (hP : P.is_local)
  {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.open_cover.{u} Y) [hùí∞ : ‚àÄ i, is_affine (ùí∞.obj i)] :
  target_affine_locally P f ‚Üî ‚àÄ i, @@P (pullback.snd : pullback f (ùí∞.map i) ‚ü∂ _) (hùí∞ i) :=
‚ü®Œª H, let h := ((hP.affine_open_cover_tfae f).out 0 2).mp H in h ùí∞,
  Œª H, let h := ((hP.affine_open_cover_tfae f).out 1 0).mp in h ‚ü®ùí∞, infer_instance, H‚ü©‚ü©

lemma affine_target_morphism_property.is_local.affine_target_iff
  {P : affine_target_morphism_property} (hP : P.is_local)
  {X Y : Scheme.{u}} (f : X ‚ü∂ Y) [is_affine Y] :
  target_affine_locally P f ‚Üî P f :=
begin
  rw hP.affine_open_cover_iff f _,
  swap, { exact Scheme.open_cover_of_is_iso (ùüô Y) },
  swap, { intro _, dsimp, apply_instance },
  transitivity (P (pullback.snd : pullback f (ùüô _) ‚ü∂ _)),
  { exact ‚ü®Œª H, H punit.star, Œª H _, H‚ü© },
  rw [‚Üê category.comp_id pullback.snd, ‚Üê pullback.condition, affine_cancel_left_is_iso hP.1],
end

/--
We say that `P : morphism_property Scheme` is local at the target if
1. `P` respects isomorphisms.
2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ U` for any `U`.
3. If `P` holds for `f ‚à£_ U` for an open cover `U` of `Y`, then `P` holds for `f`.
-/
structure property_is_local_at_target (P : morphism_property Scheme) : Prop :=
(respects_iso : P.respects_iso)
(restrict : ‚àÄ {X Y : Scheme} (f : X ‚ü∂ Y) (U : opens Y.carrier), P f ‚Üí P (f ‚à£_ U))
(of_open_cover : ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.open_cover.{u} Y),
    (‚àÄ (i : ùí∞.J), P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i)) ‚Üí P f)

lemma affine_target_morphism_property.is_local.target_affine_locally_is_local
  {P : affine_target_morphism_property} (hP : P.is_local) :
    property_is_local_at_target (target_affine_locally P) :=
begin
  constructor,
  { exact target_affine_locally_respects_iso hP.1 },
  { intros X Y f U H V,
    rw [‚Üê P.to_property_apply, hP.1.arrow_mk_iso_iff (morphism_restrict_restrict f _ _)],
    convert H ‚ü®_, is_affine_open.image_is_open_immersion V.2 (Y.of_restrict _)‚ü©,
    rw ‚Üê P.to_property_apply,
    refl },
  { rintros X Y f ùí∞ hùí∞,
    rw (hP.affine_open_cover_tfae f).out 0 1,
    refine ‚ü®ùí∞.bind (Œª _, Scheme.affine_cover _), _, _‚ü©,
    { intro i, dsimp [Scheme.open_cover.bind], apply_instance },
    { intro i,
      specialize hùí∞ i.1,
      rw (hP.affine_open_cover_tfae (pullback.snd : pullback f (ùí∞.map i.fst) ‚ü∂ _)).out 0 2
        at hùí∞,
      specialize hùí∞ (Scheme.affine_cover _) i.2,
      let e : pullback f ((ùí∞.obj i.fst).affine_cover.map i.snd ‚â´ ùí∞.map i.fst) ‚ü∂
        pullback (pullback.snd : pullback f (ùí∞.map i.fst) ‚ü∂ _)
          ((ùí∞.obj i.fst).affine_cover.map i.snd),
      { refine (pullback_symmetry _ _).hom ‚â´ _,
        refine (pullback_right_pullback_fst_iso _ _ _).inv ‚â´ _,
        refine (pullback_symmetry _ _).hom ‚â´ _,
        refine pullback.map _ _ _ _ (pullback_symmetry _ _).hom (ùüô _) (ùüô _) _ _;
          simp only [category.comp_id, category.id_comp, pullback_symmetry_hom_comp_snd] },
      rw ‚Üê affine_cancel_left_is_iso hP.1 e at hùí∞,
      convert hùí∞,
      simp } },
end

lemma property_is_local_at_target.open_cover_tfae
  {P : morphism_property Scheme}
  (hP : property_is_local_at_target P)
  {X Y : Scheme.{u}} (f : X ‚ü∂ Y) :
  tfae [P f,
    ‚àÉ (ùí∞ : Scheme.open_cover.{u} Y), ‚àÄ (i : ùí∞.J),
      P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i),
    ‚àÄ (ùí∞ : Scheme.open_cover.{u} Y) (i : ùí∞.J),
      P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i),
    ‚àÄ (U : opens Y.carrier), P (f ‚à£_ U),
    ‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [is_open_immersion g],
      P (pullback.snd : pullback f g ‚ü∂ U),
    ‚àÉ {Œπ : Type u} (U : Œπ ‚Üí opens Y.carrier) (hU : supr U = ‚ä§), (‚àÄ i, P (f ‚à£_ (U i)))] :=
begin
  tfae_have : 2 ‚Üí 1,
  { rintro ‚ü®ùí∞, H‚ü©, exact hP.3 f ùí∞ H },
  tfae_have : 1 ‚Üí 4,
  { intros H U, exact hP.2 f U H },
  tfae_have : 4 ‚Üí 3,
  { intros H ùí∞ i,
    rw ‚Üê hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _),
    exact H (ùí∞.map i).opens_range },
  tfae_have : 3 ‚Üí 2,
  { exact Œª H, ‚ü®Y.affine_cover, H Y.affine_cover‚ü© },
  tfae_have : 4 ‚Üí 5,
  { intros H U g hg,
    resetI,
    rw ‚Üê hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _),
    apply H },
  tfae_have : 5 ‚Üí 4,
  { intros H U,
    erw hP.1.cancel_left_is_iso,
    apply H },
  tfae_have : 4 ‚Üí 6,
  { intro H, exact ‚ü®punit, Œª _, ‚ä§, csupr_const, Œª _, H _‚ü© },
  tfae_have : 6 ‚Üí 2,
  { rintro ‚ü®Œπ, U, hU, H‚ü©,
    refine ‚ü®Y.open_cover_of_supr_eq_top U hU, _‚ü©,
    intro i,
    rw ‚Üê hP.1.arrow_mk_iso_iff (morphism_restrict_opens_range f _),
    convert H i,
    all_goals { ext1, exact subtype.range_coe } },
  tfae_finish
end

lemma property_is_local_at_target.open_cover_iff
  {P : morphism_property Scheme} (hP : property_is_local_at_target P)
  {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.open_cover.{u} Y) :
  P f ‚Üî ‚àÄ i, P (pullback.snd : pullback f (ùí∞.map i) ‚ü∂ _) :=
‚ü®Œª H, let h := ((hP.open_cover_tfae f).out 0 2).mp H in h ùí∞,
  Œª H, let h := ((hP.open_cover_tfae f).out 1 0).mp in h ‚ü®ùí∞, H‚ü©‚ü©

namespace affine_target_morphism_property

/-- A `P : affine_target_morphism_property` is stable under base change if `P` holds for `Y ‚ü∂ S`
implies that `P` holds for `X √ó‚Çõ Y ‚ü∂ X` with `X` and `S` affine schemes. -/
def stable_under_base_change
  (P : affine_target_morphism_property) : Prop :=
‚àÄ ‚¶ÉX Y S : Scheme‚¶Ñ [is_affine S] [is_affine X] (f : X ‚ü∂ S) (g : Y ‚ü∂ S),
  by exactI P g ‚Üí P (pullback.fst : pullback f g ‚ü∂ X)

lemma is_local.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change
  {P : affine_target_morphism_property} (hP : P.is_local) (hP' : P.stable_under_base_change)
  {X Y S : Scheme} (f : X ‚ü∂ S) (g : Y ‚ü∂ S) [is_affine S] (H : P g) :
  target_affine_locally P (pullback.fst : pullback f g ‚ü∂ X) :=
begin
  rw (hP.affine_open_cover_tfae (pullback.fst : pullback f g ‚ü∂ X)).out 0 1,
  use [X.affine_cover, infer_instance],
  intro i,
  let e := pullback_symmetry _ _ ‚â™‚â´ pullback_right_pullback_fst_iso f g (X.affine_cover.map i),
  have : e.hom ‚â´ pullback.fst = pullback.snd := by simp,
  rw [‚Üê this, affine_cancel_left_is_iso hP.1],
  apply hP'; assumption,
end

lemma is_local.stable_under_base_change
  {P : affine_target_morphism_property} (hP : P.is_local) (hP' : P.stable_under_base_change) :
  (target_affine_locally P).stable_under_base_change :=
morphism_property.stable_under_base_change.mk (target_affine_locally_respects_iso hP.respects_iso)
begin
  intros X Y S f g H,
  rw (hP.target_affine_locally_is_local.open_cover_tfae (pullback.fst : pullback f g ‚ü∂ X)).out 0 1,
  use S.affine_cover.pullback_cover f,
  intro i,
  rw (hP.affine_open_cover_tfae g).out 0 3 at H,
  let e : pullback (pullback.fst : pullback f g ‚ü∂ _) ((S.affine_cover.pullback_cover f).map i) ‚âÖ _,
  { refine pullback_symmetry _ _ ‚â™‚â´ pullback_right_pullback_fst_iso f g _ ‚â™‚â´ _ ‚â™‚â´
      (pullback_right_pullback_fst_iso (S.affine_cover.map i) g
        (pullback.snd : pullback f (S.affine_cover.map i) ‚ü∂ _)).symm,
    exact as_iso (pullback.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _)
      (by simpa using pullback.condition) (by simp)) },
  have : e.hom ‚â´ pullback.fst = pullback.snd := by simp,
  rw [‚Üê this, (target_affine_locally_respects_iso hP.1).cancel_left_is_iso],
  apply hP.target_affine_locally_pullback_fst_of_right_of_stable_under_base_change hP',
  rw [‚Üê pullback_symmetry_hom_comp_snd, affine_cancel_left_is_iso hP.1],
  apply H
end

end affine_target_morphism_property

/--
The `affine_target_morphism_property` associated to `(target_affine_locally P).diagonal`.
See `diagonal_target_affine_locally_eq_target_affine_locally`.
-/
def affine_target_morphism_property.diagonal (P : affine_target_morphism_property) :
  affine_target_morphism_property :=
Œª X Y f hf, ‚àÄ {U‚ÇÅ U‚ÇÇ : Scheme} (f‚ÇÅ : U‚ÇÅ ‚ü∂ X) (f‚ÇÇ : U‚ÇÇ ‚ü∂ X) [is_affine U‚ÇÅ] [is_affine U‚ÇÇ]
  [is_open_immersion f‚ÇÅ] [is_open_immersion f‚ÇÇ],
  by exactI P (pullback.map_desc f‚ÇÅ f‚ÇÇ f)

lemma affine_target_morphism_property.diagonal_respects_iso (P : affine_target_morphism_property)
  (hP : P.to_property.respects_iso) :
  P.diagonal.to_property.respects_iso :=
begin
  delta affine_target_morphism_property.diagonal,
  apply affine_target_morphism_property.respects_iso_mk,
  { introv H _ _,
    resetI,
    rw [pullback.map_desc_comp, affine_cancel_left_is_iso hP, affine_cancel_right_is_iso hP],
    apply H },
  { introv H _ _,
    resetI,
    rw [pullback.map_desc_comp, affine_cancel_right_is_iso hP],
    apply H }
end

lemma diagonal_target_affine_locally_of_open_cover (P : affine_target_morphism_property)
  (hP : P.is_local)
  {X Y : Scheme.{u}} (f : X ‚ü∂ Y)
  (ùí∞ : Scheme.open_cover.{u} Y)
  [‚àÄ i, is_affine (ùí∞.obj i)] (ùí∞' : Œ† i, Scheme.open_cover.{u} (pullback f (ùí∞.map i)))
  [‚àÄ i j, is_affine ((ùí∞' i).obj j)]
  (hùí∞' : ‚àÄ i j k, P (pullback.map_desc ((ùí∞' i).map j) ((ùí∞' i).map k) pullback.snd)) :
    (target_affine_locally P).diagonal f :=
begin
  refine (hP.affine_open_cover_iff _ _).mpr _,
  { exact ((Scheme.pullback.open_cover_of_base ùí∞ f f).bind (Œª i,
      Scheme.pullback.open_cover_of_left_right.{u u} (ùí∞' i) (ùí∞' i) pullback.snd pullback.snd)) },
  { intro i,
    dsimp at *,
    apply_instance },
  { rintro ‚ü®i, j, k‚ü©,
    dsimp,
    convert (affine_cancel_left_is_iso hP.1
    (pullback_diagonal_map_iso _ _ ((ùí∞' i).map j) ((ùí∞' i).map k)).inv pullback.snd).mp _,
    swap 3,
    { convert hùí∞' i j k, apply pullback.hom_ext; simp, },
    all_goals
    { apply pullback.hom_ext; simp only [category.assoc, pullback.lift_fst, pullback.lift_snd,
      pullback.lift_fst_assoc, pullback.lift_snd_assoc] } }
end

lemma affine_target_morphism_property.diagonal_of_target_affine_locally
  (P : affine_target_morphism_property)
  (hP : P.is_local) {X Y U : Scheme.{u}} (f : X ‚ü∂ Y) (g : U ‚ü∂ Y)
  [is_affine U] [is_open_immersion g] (H : (target_affine_locally P).diagonal f) :
    P.diagonal (pullback.snd : pullback f g ‚ü∂ _) :=
begin
  rintros U V f‚ÇÅ f‚ÇÇ _ _ _ _,
  resetI,
  replace H := ((hP.affine_open_cover_tfae (pullback.diagonal f)).out 0 3).mp H,
  let g‚ÇÅ := pullback.map (f‚ÇÅ ‚â´ pullback.snd)
    (f‚ÇÇ ‚â´ pullback.snd) f f
    (f‚ÇÅ ‚â´ pullback.fst)
    (f‚ÇÇ ‚â´ pullback.fst) g
    (by rw [category.assoc, category.assoc, pullback.condition])
    (by rw [category.assoc, category.assoc, pullback.condition]),
  let g‚ÇÇ : pullback f‚ÇÅ f‚ÇÇ ‚ü∂ pullback f g := pullback.fst ‚â´ f‚ÇÅ,
  specialize H g‚ÇÅ,
  rw ‚Üê affine_cancel_left_is_iso hP.1 (pullback_diagonal_map_iso f _ f‚ÇÅ f‚ÇÇ).hom,
  convert H,
  { apply pullback.hom_ext; simp only [category.assoc, pullback.lift_fst, pullback.lift_snd,
    pullback.lift_fst_assoc, pullback.lift_snd_assoc, category.comp_id,
    pullback_diagonal_map_iso_hom_fst, pullback_diagonal_map_iso_hom_snd], }
end

lemma affine_target_morphism_property.is_local.diagonal_affine_open_cover_tfae
  {P : affine_target_morphism_property}
  (hP : P.is_local) {X Y : Scheme.{u}} (f : X ‚ü∂ Y) :
  tfae [(target_affine_locally P).diagonal f,
    ‚àÉ (ùí∞ : Scheme.open_cover.{u} Y) [‚àÄ i, is_affine (ùí∞.obj i)], by exactI
      ‚àÄ (i : ùí∞.J), P.diagonal (pullback.snd : pullback f (ùí∞.map i) ‚ü∂ _),
    ‚àÄ (ùí∞ : Scheme.open_cover.{u} Y) [‚àÄ i, is_affine (ùí∞.obj i)] (i : ùí∞.J), by exactI
      P.diagonal (pullback.snd : pullback f (ùí∞.map i) ‚ü∂ _),
    ‚àÄ {U : Scheme} (g : U ‚ü∂ Y) [is_affine U] [is_open_immersion g], by exactI
      P.diagonal (pullback.snd : pullback f g ‚ü∂ _),
    ‚àÉ (ùí∞ : Scheme.open_cover.{u} Y) [‚àÄ i, is_affine (ùí∞.obj i)]
      (ùí∞' : Œ† i, Scheme.open_cover.{u} (pullback f (ùí∞.map i))) [‚àÄ i j, is_affine ((ùí∞' i).obj j)],
    by exactI ‚àÄ i j k, P (pullback.map_desc ((ùí∞' i).map j) ((ùí∞' i).map k) pullback.snd)] :=
begin
  tfae_have : 1 ‚Üí 4,
  { introv H hU hg _ _, resetI, apply P.diagonal_of_target_affine_locally; assumption },
  tfae_have : 4 ‚Üí 3,
  { introv H hùí∞, resetI, apply H },
  tfae_have : 3 ‚Üí 2,
  { exact Œª H, ‚ü®Y.affine_cover, infer_instance, H Y.affine_cover‚ü© },
  tfae_have : 2 ‚Üí 5,
  { rintro ‚ü®ùí∞, hùí∞, H‚ü©,
    resetI,
    refine ‚ü®ùí∞, infer_instance, Œª _, Scheme.affine_cover _, infer_instance, _‚ü©,
    intros i j k,
    apply H },
  tfae_have : 5 ‚Üí 1,
  { rintro ‚ü®ùí∞, _, ùí∞', _, H‚ü©,
    exactI diagonal_target_affine_locally_of_open_cover P hP f ùí∞ ùí∞' H, },
  tfae_finish
end

lemma affine_target_morphism_property.is_local.diagonal {P : affine_target_morphism_property}
  (hP : P.is_local) : P.diagonal.is_local :=
affine_target_morphism_property.is_local_of_open_cover_imply
  P.diagonal
  (P.diagonal_respects_iso hP.1)
  (Œª _ _ f, ((hP.diagonal_affine_open_cover_tfae f).out 1 3).mp)

lemma diagonal_target_affine_locally_eq_target_affine_locally (P : affine_target_morphism_property)
  (hP : P.is_local) :
  (target_affine_locally P).diagonal = target_affine_locally P.diagonal :=
begin
  ext _ _ f,
  exact ((hP.diagonal_affine_open_cover_tfae f).out 0 1).trans
    ((hP.diagonal.affine_open_cover_tfae f).out 1 0),
end

lemma universally_is_local_at_target (P : morphism_property Scheme)
  (hP : ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.open_cover.{u} Y),
    (‚àÄ (i : ùí∞.J), P (pullback.snd : (ùí∞.pullback_cover f).obj i ‚ü∂ ùí∞.obj i)) ‚Üí P f) :
  property_is_local_at_target P.universally :=
begin
  refine ‚ü®P.universally_respects_iso, Œª X Y f U, P.universally_stable_under_base_change
    (is_pullback_morphism_restrict f U).flip, _‚ü©,
  intros X Y f ùí∞ h X' Y' i‚ÇÅ i‚ÇÇ f' H,
  apply hP _ (ùí∞.pullback_cover i‚ÇÇ),
  intro i,
  dsimp,
  apply h i (pullback.lift (pullback.fst ‚â´ i‚ÇÅ) (pullback.snd ‚â´ pullback.snd) _) pullback.snd,
  swap,
  { rw [category.assoc, category.assoc, ‚Üê pullback.condition, ‚Üê pullback.condition_assoc, H.w] },
  refine (is_pullback.of_right _ (pullback.lift_snd _ _ _) (is_pullback.of_has_pullback _ _)).flip,
  rw [pullback.lift_fst, ‚Üê pullback.condition],
  exact (is_pullback.of_has_pullback _ _).paste_horiz H.flip
end

lemma universally_is_local_at_target_of_morphism_restrict (P : morphism_property Scheme)
  (hP‚ÇÅ : P.respects_iso)
  (hP‚ÇÇ : ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) {Œπ : Type u} (U : Œπ ‚Üí opens Y.carrier) (hU : supr U = ‚ä§),
    (‚àÄ i, P (f ‚à£_ (U i))) ‚Üí P f) :
  property_is_local_at_target P.universally :=
universally_is_local_at_target P
begin
  intros X Y f ùí∞ hùí∞,
  apply hP‚ÇÇ f (Œª (i : ùí∞.J), (ùí∞.map i).opens_range) ùí∞.supr_opens_range,
  simp_rw hP‚ÇÅ.arrow_mk_iso_iff (morphism_restrict_opens_range f _),
  exact hùí∞
end

/-- `topologically P` holds for a morphism if the underlying topological map satisfies `P`. -/
def morphism_property.topologically
  (P : ‚àÄ {Œ± Œ≤ : Type u} [topological_space Œ±] [topological_space Œ≤] (f : Œ± ‚Üí Œ≤), Prop) :
  morphism_property Scheme.{u} :=
Œª X Y f, P f.1.base

end algebraic_geometry
