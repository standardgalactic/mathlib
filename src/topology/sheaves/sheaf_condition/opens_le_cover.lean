/-
Copyright (c) 2020 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison
-/
import topology.sheaves.sheaf_condition.sites

/-!
# Another version of the sheaf condition.

> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.
> Any changes to this file require a corresponding PR to mathlib4.

Given a family of open sets `U : ι → opens X` we can form the subcategory
`{ V : opens X // ∃ i, V ≤ U i }`, which has `supr U` as a cocone.

The sheaf condition on a presheaf `F` is equivalent to
`F` sending the opposite of this cocone to a limit cone in `C`, for every `U`.

This condition is particularly nice when checking the sheaf condition
because we don't need to do any case bashing
(depending on whether we're looking at single or double intersections,
or equivalently whether we're looking at the first or second object in an equalizer diagram).

## Main statement

`Top.presheaf.is_sheaf_iff_is_sheaf_opens_le_cover`: for a presheaf on a topological space,
the sheaf condition in terms of Grothendieck topology is equivalent to the `opens_le_cover`
sheaf condition. This result will be used to further connect to other sheaf conditions on spaces,
like `pairwise_intersections` and `equalizer_products`.

## References
* This is the definition Lurie uses in [Spectral Algebraic Geometry][LurieSAG].
-/

universes w v u

noncomputable theory

open category_theory category_theory.limits topological_space topological_space.opens opposite

namespace Top

variables {C : Type u} [category.{v} C]
variables {X : Top.{w}} (F : presheaf C X) {ι : Type w} (U : ι → opens X)

namespace presheaf

namespace sheaf_condition

/--
The category of open sets contained in some element of the cover.
-/
@[derive category]
def opens_le_cover : Type w := full_subcategory (λ (V : opens X), ∃ i, V ≤ U i)

instance [inhabited ι] : inhabited (opens_le_cover U) :=
⟨⟨⊥, default, bot_le⟩⟩

namespace opens_le_cover

variables {U}

/--
An arbitrarily chosen index such that `V ≤ U i`.
-/
def index (V : opens_le_cover U) : ι := V.property.some

/--
The morphism from `V` to `U i` for some `i`.
-/
def hom_to_index (V : opens_le_cover U) : V.obj ⟶ U (index V) :=
(V.property.some_spec).hom

end opens_le_cover

/--
`supr U` as a cocone over the opens sets contained in some element of the cover.

(In fact this is a colimit cocone.)
-/
def opens_le_cover_cocone : cocone (full_subcategory_inclusion _ : opens_le_cover U ⥤ opens X) :=
{ X := supr U,
  ι := { app := λ V : opens_le_cover U, V.hom_to_index ≫ opens.le_supr U _, } }

end sheaf_condition

open sheaf_condition

/--
An equivalent formulation of the sheaf condition
(which we prove equivalent to the usual one below as
`is_sheaf_iff_is_sheaf_opens_le_cover`).

A presheaf is a sheaf if `F` sends the cone `(opens_le_cover_cocone U).op` to a limit cone.
(Recall `opens_le_cover_cocone U`, has cone point `supr U`,
mapping down to any `V` which is contained in some `U i`.)
-/
def is_sheaf_opens_le_cover : Prop :=
∀ ⦃ι : Type w⦄ (U : ι → opens X), nonempty (is_limit (F.map_cone (opens_le_cover_cocone U).op))

section

variables {Y : opens X} (hY : Y = supr U)

/-- Given a family of opens `U` and an open `Y` equal to the union of opens in `U`, we may
    take the presieve on `Y` associated to `U` and the sieve generated by it, and form the
    full subcategory (subposet) of opens contained in `Y` (`over Y`) consisting of arrows
    in the sieve. This full subcategory is equivalent to `opens_le_cover U`, the (poset)
    category of opens contained in some `U i`. -/
@[simps] def generate_equivalence_opens_le :
  full_subcategory (λ (f : over Y), (sieve.generate (presieve_of_covering_aux U Y)).arrows f.hom) ≌
  opens_le_cover U :=
{ functor :=
  { obj := λ f, ⟨f.1.left, let ⟨_,h,_,⟨i,hY⟩,_⟩ := f.2 in ⟨i, hY ▸ h.le⟩⟩,
    map := λ _ _ g, g.left },
  inverse :=
  { obj := λ V, ⟨over.mk (hY.substr (let ⟨i,h⟩ := V.2 in h.trans (le_supr U i))).hom,
      let ⟨i,h⟩ := V.2 in ⟨U i, h.hom, (hY.substr (le_supr U i)).hom, ⟨i, rfl⟩, rfl⟩⟩,
    map := λ _ _ g, over.hom_mk g },
  unit_iso := eq_to_iso $ category_theory.functor.ext
    (by {rintro ⟨⟨_,_⟩,_⟩, dsimp, congr; ext}) (by {intros, ext}),
  counit_iso := eq_to_iso $ category_theory.functor.hext
    (by {intro, ext, refl}) (by {intros, refl}) }

/-- Given a family of opens `opens_le_cover_cocone U` is essentially the natural cocone
    associated to the sieve generated by the presieve associated to `U` with indexing
    category changed using the above equivalence. -/
@[simps] def whisker_iso_map_generate_cocone :
  (F.map_cone (opens_le_cover_cocone U).op).whisker (generate_equivalence_opens_le U hY).op.functor
    ≅ F.map_cone (sieve.generate (presieve_of_covering_aux U Y)).arrows.cocone.op :=
{ hom :=
  { hom := F.map (eq_to_hom (congr_arg op hY.symm)),
    w' := λ j, by { erw ← F.map_comp, congr } },
  inv :=
  { hom := F.map (eq_to_hom (congr_arg op hY)),
    w' := λ j, by { erw ← F.map_comp, congr } },
  hom_inv_id' := by { ext, simp [eq_to_hom_map], },
  inv_hom_id' := by { ext, simp [eq_to_hom_map], } }

/-- Given a presheaf `F` on the topological space `X` and a family of opens `U` of `X`,
    the natural cone associated to `F` and `U` used in the definition of
    `F.is_sheaf_opens_le_cover` is a limit cone iff the natural cone associated to `F`
    and the sieve generated by the presieve associated to `U` is a limit cone. -/
def is_limit_opens_le_equiv_generate₁ :
  is_limit (F.map_cone (opens_le_cover_cocone U).op) ≃
  is_limit (F.map_cone (sieve.generate (presieve_of_covering_aux U Y)).arrows.cocone.op) :=
(is_limit.whisker_equivalence_equiv (generate_equivalence_opens_le U hY).op).trans
  (is_limit.equiv_iso_limit (whisker_iso_map_generate_cocone F U hY))

/-- Given a presheaf `F` on the topological space `X` and a presieve `R` whose generated sieve
    is covering for the associated Grothendieck topology (equivalently, the presieve is covering
    for the associated pretopology), the natural cone associated to `F` and the family of opens
    associated to `R` is a limit cone iff the natural cone associated to `F` and the generated
    sieve is a limit cone.
    Since only the existence of a 1-1 correspondence will be used, the exact definition does
    not matter, so tactics are used liberally. -/
def is_limit_opens_le_equiv_generate₂ (R : presieve Y)
  (hR : sieve.generate R ∈ opens.grothendieck_topology X Y) :
  is_limit (F.map_cone (opens_le_cover_cocone (covering_of_presieve Y R)).op) ≃
  is_limit (F.map_cone (sieve.generate R).arrows.cocone.op) :=
begin
  convert is_limit_opens_le_equiv_generate₁ F (covering_of_presieve Y R)
    (covering_of_presieve.supr_eq_of_mem_grothendieck Y R hR).symm using 2;
  rw covering_presieve_eq_self R,
end

/-- A presheaf `(opens X)ᵒᵖ ⥤ C` on a topological space `X` is a sheaf on the site `opens X` iff
    it satisfies the `is_sheaf_opens_le_cover` sheaf condition. The latter is not the
    official definition of sheaves on spaces, but has the advantage that it does not
    require `has_products C`. -/
lemma is_sheaf_iff_is_sheaf_opens_le_cover :
  F.is_sheaf ↔ F.is_sheaf_opens_le_cover :=
begin
  refine (presheaf.is_sheaf_iff_is_limit _ _).trans _,
  split,
  { intros h ι U, rw (is_limit_opens_le_equiv_generate₁ F U rfl).nonempty_congr,
    apply h, apply presieve_of_covering.mem_grothendieck_topology },
  { intros h Y S, rw ← sieve.generate_sieve S, intro hS,
    rw ← (is_limit_opens_le_equiv_generate₂ F S hS).nonempty_congr, apply h },
end

end

end presheaf

end Top
